
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model supervisor
 * 
 */
export type supervisor = $Result.DefaultSelection<Prisma.$supervisorPayload>
/**
 * Model student
 * 
 */
export type student = $Result.DefaultSelection<Prisma.$studentPayload>
/**
 * Model inscription
 * 
 */
export type inscription = $Result.DefaultSelection<Prisma.$inscriptionPayload>
/**
 * Model group
 * 
 */
export type group = $Result.DefaultSelection<Prisma.$groupPayload>
/**
 * Model semester
 * 
 */
export type semester = $Result.DefaultSelection<Prisma.$semesterPayload>
/**
 * Model course_material
 * 
 */
export type course_material = $Result.DefaultSelection<Prisma.$course_materialPayload>
/**
 * Model session_type
 * 
 */
export type session_type = $Result.DefaultSelection<Prisma.$session_typePayload>
/**
 * Model presence
 * 
 */
export type presence = $Result.DefaultSelection<Prisma.$presencePayload>
/**
 * Model slot
 * 
 */
export type slot = $Result.DefaultSelection<Prisma.$slotPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Supervisors
 * const supervisors = await prisma.supervisor.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Supervisors
   * const supervisors = await prisma.supervisor.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.supervisor`: Exposes CRUD operations for the **supervisor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supervisors
    * const supervisors = await prisma.supervisor.findMany()
    * ```
    */
  get supervisor(): Prisma.supervisorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.studentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inscription`: Exposes CRUD operations for the **inscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inscriptions
    * const inscriptions = await prisma.inscription.findMany()
    * ```
    */
  get inscription(): Prisma.inscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.groupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.semester`: Exposes CRUD operations for the **semester** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Semesters
    * const semesters = await prisma.semester.findMany()
    * ```
    */
  get semester(): Prisma.semesterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course_material`: Exposes CRUD operations for the **course_material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Course_materials
    * const course_materials = await prisma.course_material.findMany()
    * ```
    */
  get course_material(): Prisma.course_materialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session_type`: Exposes CRUD operations for the **session_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Session_types
    * const session_types = await prisma.session_type.findMany()
    * ```
    */
  get session_type(): Prisma.session_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.presence`: Exposes CRUD operations for the **presence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presences
    * const presences = await prisma.presence.findMany()
    * ```
    */
  get presence(): Prisma.presenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slot`: Exposes CRUD operations for the **slot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Slots
    * const slots = await prisma.slot.findMany()
    * ```
    */
  get slot(): Prisma.slotDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    supervisor: 'supervisor',
    student: 'student',
    inscription: 'inscription',
    group: 'group',
    semester: 'semester',
    course_material: 'course_material',
    session_type: 'session_type',
    presence: 'presence',
    slot: 'slot'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "supervisor" | "student" | "inscription" | "group" | "semester" | "course_material" | "session_type" | "presence" | "slot"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      supervisor: {
        payload: Prisma.$supervisorPayload<ExtArgs>
        fields: Prisma.supervisorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supervisorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supervisorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>
          }
          findFirst: {
            args: Prisma.supervisorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supervisorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>
          }
          findMany: {
            args: Prisma.supervisorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>[]
          }
          create: {
            args: Prisma.supervisorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>
          }
          createMany: {
            args: Prisma.supervisorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.supervisorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>[]
          }
          delete: {
            args: Prisma.supervisorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>
          }
          update: {
            args: Prisma.supervisorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>
          }
          deleteMany: {
            args: Prisma.supervisorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.supervisorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.supervisorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>[]
          }
          upsert: {
            args: Prisma.supervisorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supervisorPayload>
          }
          aggregate: {
            args: Prisma.SupervisorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupervisor>
          }
          groupBy: {
            args: Prisma.supervisorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupervisorGroupByOutputType>[]
          }
          count: {
            args: Prisma.supervisorCountArgs<ExtArgs>
            result: $Utils.Optional<SupervisorCountAggregateOutputType> | number
          }
        }
      }
      student: {
        payload: Prisma.$studentPayload<ExtArgs>
        fields: Prisma.studentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findFirst: {
            args: Prisma.studentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findMany: {
            args: Prisma.studentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          create: {
            args: Prisma.studentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          createMany: {
            args: Prisma.studentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.studentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          delete: {
            args: Prisma.studentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          update: {
            args: Prisma.studentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          deleteMany: {
            args: Prisma.studentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.studentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          upsert: {
            args: Prisma.studentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.studentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      inscription: {
        payload: Prisma.$inscriptionPayload<ExtArgs>
        fields: Prisma.inscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>
          }
          findFirst: {
            args: Prisma.inscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>
          }
          findMany: {
            args: Prisma.inscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>[]
          }
          create: {
            args: Prisma.inscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>
          }
          createMany: {
            args: Prisma.inscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>[]
          }
          delete: {
            args: Prisma.inscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>
          }
          update: {
            args: Prisma.inscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>
          }
          deleteMany: {
            args: Prisma.inscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>[]
          }
          upsert: {
            args: Prisma.inscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscriptionPayload>
          }
          aggregate: {
            args: Prisma.InscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInscription>
          }
          groupBy: {
            args: Prisma.inscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.inscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<InscriptionCountAggregateOutputType> | number
          }
        }
      }
      group: {
        payload: Prisma.$groupPayload<ExtArgs>
        fields: Prisma.groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          findFirst: {
            args: Prisma.groupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          findMany: {
            args: Prisma.groupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>[]
          }
          create: {
            args: Prisma.groupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          createMany: {
            args: Prisma.groupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.groupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>[]
          }
          delete: {
            args: Prisma.groupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          update: {
            args: Prisma.groupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          deleteMany: {
            args: Prisma.groupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.groupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.groupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>[]
          }
          upsert: {
            args: Prisma.groupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.groupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      semester: {
        payload: Prisma.$semesterPayload<ExtArgs>
        fields: Prisma.semesterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.semesterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.semesterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>
          }
          findFirst: {
            args: Prisma.semesterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.semesterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>
          }
          findMany: {
            args: Prisma.semesterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>[]
          }
          create: {
            args: Prisma.semesterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>
          }
          createMany: {
            args: Prisma.semesterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.semesterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>[]
          }
          delete: {
            args: Prisma.semesterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>
          }
          update: {
            args: Prisma.semesterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>
          }
          deleteMany: {
            args: Prisma.semesterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.semesterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.semesterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>[]
          }
          upsert: {
            args: Prisma.semesterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semesterPayload>
          }
          aggregate: {
            args: Prisma.SemesterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSemester>
          }
          groupBy: {
            args: Prisma.semesterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SemesterGroupByOutputType>[]
          }
          count: {
            args: Prisma.semesterCountArgs<ExtArgs>
            result: $Utils.Optional<SemesterCountAggregateOutputType> | number
          }
        }
      }
      course_material: {
        payload: Prisma.$course_materialPayload<ExtArgs>
        fields: Prisma.course_materialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.course_materialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.course_materialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>
          }
          findFirst: {
            args: Prisma.course_materialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.course_materialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>
          }
          findMany: {
            args: Prisma.course_materialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>[]
          }
          create: {
            args: Prisma.course_materialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>
          }
          createMany: {
            args: Prisma.course_materialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.course_materialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>[]
          }
          delete: {
            args: Prisma.course_materialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>
          }
          update: {
            args: Prisma.course_materialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>
          }
          deleteMany: {
            args: Prisma.course_materialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.course_materialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.course_materialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>[]
          }
          upsert: {
            args: Prisma.course_materialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_materialPayload>
          }
          aggregate: {
            args: Prisma.Course_materialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse_material>
          }
          groupBy: {
            args: Prisma.course_materialGroupByArgs<ExtArgs>
            result: $Utils.Optional<Course_materialGroupByOutputType>[]
          }
          count: {
            args: Prisma.course_materialCountArgs<ExtArgs>
            result: $Utils.Optional<Course_materialCountAggregateOutputType> | number
          }
        }
      }
      session_type: {
        payload: Prisma.$session_typePayload<ExtArgs>
        fields: Prisma.session_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.session_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.session_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>
          }
          findFirst: {
            args: Prisma.session_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.session_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>
          }
          findMany: {
            args: Prisma.session_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>[]
          }
          create: {
            args: Prisma.session_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>
          }
          createMany: {
            args: Prisma.session_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.session_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>[]
          }
          delete: {
            args: Prisma.session_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>
          }
          update: {
            args: Prisma.session_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>
          }
          deleteMany: {
            args: Prisma.session_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.session_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.session_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>[]
          }
          upsert: {
            args: Prisma.session_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_typePayload>
          }
          aggregate: {
            args: Prisma.Session_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession_type>
          }
          groupBy: {
            args: Prisma.session_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Session_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.session_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Session_typeCountAggregateOutputType> | number
          }
        }
      }
      presence: {
        payload: Prisma.$presencePayload<ExtArgs>
        fields: Prisma.presenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.presenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.presenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>
          }
          findFirst: {
            args: Prisma.presenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.presenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>
          }
          findMany: {
            args: Prisma.presenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>[]
          }
          create: {
            args: Prisma.presenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>
          }
          createMany: {
            args: Prisma.presenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.presenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>[]
          }
          delete: {
            args: Prisma.presenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>
          }
          update: {
            args: Prisma.presenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>
          }
          deleteMany: {
            args: Prisma.presenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.presenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.presenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>[]
          }
          upsert: {
            args: Prisma.presenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$presencePayload>
          }
          aggregate: {
            args: Prisma.PresenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePresence>
          }
          groupBy: {
            args: Prisma.presenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.presenceCountArgs<ExtArgs>
            result: $Utils.Optional<PresenceCountAggregateOutputType> | number
          }
        }
      }
      slot: {
        payload: Prisma.$slotPayload<ExtArgs>
        fields: Prisma.slotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.slotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.slotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>
          }
          findFirst: {
            args: Prisma.slotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.slotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>
          }
          findMany: {
            args: Prisma.slotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>[]
          }
          create: {
            args: Prisma.slotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>
          }
          createMany: {
            args: Prisma.slotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.slotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>[]
          }
          delete: {
            args: Prisma.slotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>
          }
          update: {
            args: Prisma.slotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>
          }
          deleteMany: {
            args: Prisma.slotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.slotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.slotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>[]
          }
          upsert: {
            args: Prisma.slotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slotPayload>
          }
          aggregate: {
            args: Prisma.SlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlot>
          }
          groupBy: {
            args: Prisma.slotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.slotCountArgs<ExtArgs>
            result: $Utils.Optional<SlotCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    supervisor?: supervisorOmit
    student?: studentOmit
    inscription?: inscriptionOmit
    group?: groupOmit
    semester?: semesterOmit
    course_material?: course_materialOmit
    session_type?: session_typeOmit
    presence?: presenceOmit
    slot?: slotOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SupervisorCountOutputType
   */

  export type SupervisorCountOutputType = {
    supervisor_slot: number
  }

  export type SupervisorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supervisor_slot?: boolean | SupervisorCountOutputTypeCountSupervisor_slotArgs
  }

  // Custom InputTypes
  /**
   * SupervisorCountOutputType without action
   */
  export type SupervisorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupervisorCountOutputType
     */
    select?: SupervisorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupervisorCountOutputType without action
   */
  export type SupervisorCountOutputTypeCountSupervisor_slotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: slotWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    student_inscription: number
    student_presence: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_inscription?: boolean | StudentCountOutputTypeCountStudent_inscriptionArgs
    student_presence?: boolean | StudentCountOutputTypeCountStudent_presenceArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudent_inscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscriptionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudent_presenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: presenceWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    group_inscription: number
    group_slot: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_inscription?: boolean | GroupCountOutputTypeCountGroup_inscriptionArgs
    group_slot?: boolean | GroupCountOutputTypeCountGroup_slotArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountGroup_inscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscriptionWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountGroup_slotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: slotWhereInput
  }


  /**
   * Count Type SemesterCountOutputType
   */

  export type SemesterCountOutputType = {
    semester_group: number
    semester_course_material: number
  }

  export type SemesterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semester_group?: boolean | SemesterCountOutputTypeCountSemester_groupArgs
    semester_course_material?: boolean | SemesterCountOutputTypeCountSemester_course_materialArgs
  }

  // Custom InputTypes
  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterCountOutputType
     */
    select?: SemesterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountSemester_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountSemester_course_materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_materialWhereInput
  }


  /**
   * Count Type Course_materialCountOutputType
   */

  export type Course_materialCountOutputType = {
    course_material_session_type: number
  }

  export type Course_materialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_material_session_type?: boolean | Course_materialCountOutputTypeCountCourse_material_session_typeArgs
  }

  // Custom InputTypes
  /**
   * Course_materialCountOutputType without action
   */
  export type Course_materialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course_materialCountOutputType
     */
    select?: Course_materialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Course_materialCountOutputType without action
   */
  export type Course_materialCountOutputTypeCountCourse_material_session_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_typeWhereInput
  }


  /**
   * Count Type Session_typeCountOutputType
   */

  export type Session_typeCountOutputType = {
    session_type_slot: number
  }

  export type Session_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session_type_slot?: boolean | Session_typeCountOutputTypeCountSession_type_slotArgs
  }

  // Custom InputTypes
  /**
   * Session_typeCountOutputType without action
   */
  export type Session_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session_typeCountOutputType
     */
    select?: Session_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Session_typeCountOutputType without action
   */
  export type Session_typeCountOutputTypeCountSession_type_slotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: slotWhereInput
  }


  /**
   * Count Type SlotCountOutputType
   */

  export type SlotCountOutputType = {
    slot_presence: number
  }

  export type SlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slot_presence?: boolean | SlotCountOutputTypeCountSlot_presenceArgs
  }

  // Custom InputTypes
  /**
   * SlotCountOutputType without action
   */
  export type SlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotCountOutputType
     */
    select?: SlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SlotCountOutputType without action
   */
  export type SlotCountOutputTypeCountSlot_presenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: presenceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model supervisor
   */

  export type AggregateSupervisor = {
    _count: SupervisorCountAggregateOutputType | null
    _min: SupervisorMinAggregateOutputType | null
    _max: SupervisorMaxAggregateOutputType | null
  }

  export type SupervisorMinAggregateOutputType = {
    id: string | null
    name: string | null
    mail: string | null
  }

  export type SupervisorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    mail: string | null
  }

  export type SupervisorCountAggregateOutputType = {
    id: number
    name: number
    mail: number
    _all: number
  }


  export type SupervisorMinAggregateInputType = {
    id?: true
    name?: true
    mail?: true
  }

  export type SupervisorMaxAggregateInputType = {
    id?: true
    name?: true
    mail?: true
  }

  export type SupervisorCountAggregateInputType = {
    id?: true
    name?: true
    mail?: true
    _all?: true
  }

  export type SupervisorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supervisor to aggregate.
     */
    where?: supervisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supervisors to fetch.
     */
    orderBy?: supervisorOrderByWithRelationInput | supervisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supervisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned supervisors
    **/
    _count?: true | SupervisorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupervisorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupervisorMaxAggregateInputType
  }

  export type GetSupervisorAggregateType<T extends SupervisorAggregateArgs> = {
        [P in keyof T & keyof AggregateSupervisor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupervisor[P]>
      : GetScalarType<T[P], AggregateSupervisor[P]>
  }




  export type supervisorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supervisorWhereInput
    orderBy?: supervisorOrderByWithAggregationInput | supervisorOrderByWithAggregationInput[]
    by: SupervisorScalarFieldEnum[] | SupervisorScalarFieldEnum
    having?: supervisorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupervisorCountAggregateInputType | true
    _min?: SupervisorMinAggregateInputType
    _max?: SupervisorMaxAggregateInputType
  }

  export type SupervisorGroupByOutputType = {
    id: string
    name: string
    mail: string
    _count: SupervisorCountAggregateOutputType | null
    _min: SupervisorMinAggregateOutputType | null
    _max: SupervisorMaxAggregateOutputType | null
  }

  type GetSupervisorGroupByPayload<T extends supervisorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupervisorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupervisorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupervisorGroupByOutputType[P]>
            : GetScalarType<T[P], SupervisorGroupByOutputType[P]>
        }
      >
    >


  export type supervisorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mail?: boolean
    supervisor_slot?: boolean | supervisor$supervisor_slotArgs<ExtArgs>
    _count?: boolean | SupervisorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supervisor"]>

  export type supervisorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mail?: boolean
  }, ExtArgs["result"]["supervisor"]>

  export type supervisorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mail?: boolean
  }, ExtArgs["result"]["supervisor"]>

  export type supervisorSelectScalar = {
    id?: boolean
    name?: boolean
    mail?: boolean
  }

  export type supervisorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "mail", ExtArgs["result"]["supervisor"]>
  export type supervisorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supervisor_slot?: boolean | supervisor$supervisor_slotArgs<ExtArgs>
    _count?: boolean | SupervisorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type supervisorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type supervisorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $supervisorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supervisor"
    objects: {
      supervisor_slot: Prisma.$slotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      mail: string
    }, ExtArgs["result"]["supervisor"]>
    composites: {}
  }

  type supervisorGetPayload<S extends boolean | null | undefined | supervisorDefaultArgs> = $Result.GetResult<Prisma.$supervisorPayload, S>

  type supervisorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<supervisorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupervisorCountAggregateInputType | true
    }

  export interface supervisorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supervisor'], meta: { name: 'supervisor' } }
    /**
     * Find zero or one Supervisor that matches the filter.
     * @param {supervisorFindUniqueArgs} args - Arguments to find a Supervisor
     * @example
     * // Get one Supervisor
     * const supervisor = await prisma.supervisor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends supervisorFindUniqueArgs>(args: SelectSubset<T, supervisorFindUniqueArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supervisor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {supervisorFindUniqueOrThrowArgs} args - Arguments to find a Supervisor
     * @example
     * // Get one Supervisor
     * const supervisor = await prisma.supervisor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends supervisorFindUniqueOrThrowArgs>(args: SelectSubset<T, supervisorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supervisor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisorFindFirstArgs} args - Arguments to find a Supervisor
     * @example
     * // Get one Supervisor
     * const supervisor = await prisma.supervisor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends supervisorFindFirstArgs>(args?: SelectSubset<T, supervisorFindFirstArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supervisor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisorFindFirstOrThrowArgs} args - Arguments to find a Supervisor
     * @example
     * // Get one Supervisor
     * const supervisor = await prisma.supervisor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends supervisorFindFirstOrThrowArgs>(args?: SelectSubset<T, supervisorFindFirstOrThrowArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Supervisors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supervisors
     * const supervisors = await prisma.supervisor.findMany()
     * 
     * // Get first 10 Supervisors
     * const supervisors = await prisma.supervisor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supervisorWithIdOnly = await prisma.supervisor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends supervisorFindManyArgs>(args?: SelectSubset<T, supervisorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supervisor.
     * @param {supervisorCreateArgs} args - Arguments to create a Supervisor.
     * @example
     * // Create one Supervisor
     * const Supervisor = await prisma.supervisor.create({
     *   data: {
     *     // ... data to create a Supervisor
     *   }
     * })
     * 
     */
    create<T extends supervisorCreateArgs>(args: SelectSubset<T, supervisorCreateArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Supervisors.
     * @param {supervisorCreateManyArgs} args - Arguments to create many Supervisors.
     * @example
     * // Create many Supervisors
     * const supervisor = await prisma.supervisor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends supervisorCreateManyArgs>(args?: SelectSubset<T, supervisorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Supervisors and returns the data saved in the database.
     * @param {supervisorCreateManyAndReturnArgs} args - Arguments to create many Supervisors.
     * @example
     * // Create many Supervisors
     * const supervisor = await prisma.supervisor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Supervisors and only return the `id`
     * const supervisorWithIdOnly = await prisma.supervisor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends supervisorCreateManyAndReturnArgs>(args?: SelectSubset<T, supervisorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supervisor.
     * @param {supervisorDeleteArgs} args - Arguments to delete one Supervisor.
     * @example
     * // Delete one Supervisor
     * const Supervisor = await prisma.supervisor.delete({
     *   where: {
     *     // ... filter to delete one Supervisor
     *   }
     * })
     * 
     */
    delete<T extends supervisorDeleteArgs>(args: SelectSubset<T, supervisorDeleteArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supervisor.
     * @param {supervisorUpdateArgs} args - Arguments to update one Supervisor.
     * @example
     * // Update one Supervisor
     * const supervisor = await prisma.supervisor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends supervisorUpdateArgs>(args: SelectSubset<T, supervisorUpdateArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Supervisors.
     * @param {supervisorDeleteManyArgs} args - Arguments to filter Supervisors to delete.
     * @example
     * // Delete a few Supervisors
     * const { count } = await prisma.supervisor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends supervisorDeleteManyArgs>(args?: SelectSubset<T, supervisorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supervisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supervisors
     * const supervisor = await prisma.supervisor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends supervisorUpdateManyArgs>(args: SelectSubset<T, supervisorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supervisors and returns the data updated in the database.
     * @param {supervisorUpdateManyAndReturnArgs} args - Arguments to update many Supervisors.
     * @example
     * // Update many Supervisors
     * const supervisor = await prisma.supervisor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Supervisors and only return the `id`
     * const supervisorWithIdOnly = await prisma.supervisor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends supervisorUpdateManyAndReturnArgs>(args: SelectSubset<T, supervisorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supervisor.
     * @param {supervisorUpsertArgs} args - Arguments to update or create a Supervisor.
     * @example
     * // Update or create a Supervisor
     * const supervisor = await prisma.supervisor.upsert({
     *   create: {
     *     // ... data to create a Supervisor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supervisor we want to update
     *   }
     * })
     */
    upsert<T extends supervisorUpsertArgs>(args: SelectSubset<T, supervisorUpsertArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Supervisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisorCountArgs} args - Arguments to filter Supervisors to count.
     * @example
     * // Count the number of Supervisors
     * const count = await prisma.supervisor.count({
     *   where: {
     *     // ... the filter for the Supervisors we want to count
     *   }
     * })
    **/
    count<T extends supervisorCountArgs>(
      args?: Subset<T, supervisorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupervisorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supervisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupervisorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupervisorAggregateArgs>(args: Subset<T, SupervisorAggregateArgs>): Prisma.PrismaPromise<GetSupervisorAggregateType<T>>

    /**
     * Group by Supervisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supervisorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supervisorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supervisorGroupByArgs['orderBy'] }
        : { orderBy?: supervisorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supervisorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupervisorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supervisor model
   */
  readonly fields: supervisorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supervisor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supervisorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supervisor_slot<T extends supervisor$supervisor_slotArgs<ExtArgs> = {}>(args?: Subset<T, supervisor$supervisor_slotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the supervisor model
   */
  interface supervisorFieldRefs {
    readonly id: FieldRef<"supervisor", 'String'>
    readonly name: FieldRef<"supervisor", 'String'>
    readonly mail: FieldRef<"supervisor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * supervisor findUnique
   */
  export type supervisorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * Filter, which supervisor to fetch.
     */
    where: supervisorWhereUniqueInput
  }

  /**
   * supervisor findUniqueOrThrow
   */
  export type supervisorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * Filter, which supervisor to fetch.
     */
    where: supervisorWhereUniqueInput
  }

  /**
   * supervisor findFirst
   */
  export type supervisorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * Filter, which supervisor to fetch.
     */
    where?: supervisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supervisors to fetch.
     */
    orderBy?: supervisorOrderByWithRelationInput | supervisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supervisors.
     */
    cursor?: supervisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supervisors.
     */
    distinct?: SupervisorScalarFieldEnum | SupervisorScalarFieldEnum[]
  }

  /**
   * supervisor findFirstOrThrow
   */
  export type supervisorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * Filter, which supervisor to fetch.
     */
    where?: supervisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supervisors to fetch.
     */
    orderBy?: supervisorOrderByWithRelationInput | supervisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supervisors.
     */
    cursor?: supervisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supervisors.
     */
    distinct?: SupervisorScalarFieldEnum | SupervisorScalarFieldEnum[]
  }

  /**
   * supervisor findMany
   */
  export type supervisorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * Filter, which supervisors to fetch.
     */
    where?: supervisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supervisors to fetch.
     */
    orderBy?: supervisorOrderByWithRelationInput | supervisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing supervisors.
     */
    cursor?: supervisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supervisors.
     */
    skip?: number
    distinct?: SupervisorScalarFieldEnum | SupervisorScalarFieldEnum[]
  }

  /**
   * supervisor create
   */
  export type supervisorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * The data needed to create a supervisor.
     */
    data: XOR<supervisorCreateInput, supervisorUncheckedCreateInput>
  }

  /**
   * supervisor createMany
   */
  export type supervisorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many supervisors.
     */
    data: supervisorCreateManyInput | supervisorCreateManyInput[]
  }

  /**
   * supervisor createManyAndReturn
   */
  export type supervisorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * The data used to create many supervisors.
     */
    data: supervisorCreateManyInput | supervisorCreateManyInput[]
  }

  /**
   * supervisor update
   */
  export type supervisorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * The data needed to update a supervisor.
     */
    data: XOR<supervisorUpdateInput, supervisorUncheckedUpdateInput>
    /**
     * Choose, which supervisor to update.
     */
    where: supervisorWhereUniqueInput
  }

  /**
   * supervisor updateMany
   */
  export type supervisorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update supervisors.
     */
    data: XOR<supervisorUpdateManyMutationInput, supervisorUncheckedUpdateManyInput>
    /**
     * Filter which supervisors to update
     */
    where?: supervisorWhereInput
    /**
     * Limit how many supervisors to update.
     */
    limit?: number
  }

  /**
   * supervisor updateManyAndReturn
   */
  export type supervisorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * The data used to update supervisors.
     */
    data: XOR<supervisorUpdateManyMutationInput, supervisorUncheckedUpdateManyInput>
    /**
     * Filter which supervisors to update
     */
    where?: supervisorWhereInput
    /**
     * Limit how many supervisors to update.
     */
    limit?: number
  }

  /**
   * supervisor upsert
   */
  export type supervisorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * The filter to search for the supervisor to update in case it exists.
     */
    where: supervisorWhereUniqueInput
    /**
     * In case the supervisor found by the `where` argument doesn't exist, create a new supervisor with this data.
     */
    create: XOR<supervisorCreateInput, supervisorUncheckedCreateInput>
    /**
     * In case the supervisor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supervisorUpdateInput, supervisorUncheckedUpdateInput>
  }

  /**
   * supervisor delete
   */
  export type supervisorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
    /**
     * Filter which supervisor to delete.
     */
    where: supervisorWhereUniqueInput
  }

  /**
   * supervisor deleteMany
   */
  export type supervisorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supervisors to delete
     */
    where?: supervisorWhereInput
    /**
     * Limit how many supervisors to delete.
     */
    limit?: number
  }

  /**
   * supervisor.supervisor_slot
   */
  export type supervisor$supervisor_slotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    where?: slotWhereInput
    orderBy?: slotOrderByWithRelationInput | slotOrderByWithRelationInput[]
    cursor?: slotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * supervisor without action
   */
  export type supervisorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supervisor
     */
    select?: supervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supervisor
     */
    omit?: supervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supervisorInclude<ExtArgs> | null
  }


  /**
   * Model student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    name: string | null
    first_name: string | null
    mail: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    first_name: string | null
    mail: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    name: number
    first_name: number
    mail: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    mail?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    mail?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    name?: true
    first_name?: true
    mail?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student to aggregate.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type studentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
    orderBy?: studentOrderByWithAggregationInput | studentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: studentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    name: string
    first_name: string
    mail: string
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends studentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type studentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    mail?: boolean
    student_inscription?: boolean | student$student_inscriptionArgs<ExtArgs>
    student_presence?: boolean | student$student_presenceArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type studentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    mail?: boolean
  }, ExtArgs["result"]["student"]>

  export type studentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    first_name?: boolean
    mail?: boolean
  }, ExtArgs["result"]["student"]>

  export type studentSelectScalar = {
    id?: boolean
    name?: boolean
    first_name?: boolean
    mail?: boolean
  }

  export type studentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "first_name" | "mail", ExtArgs["result"]["student"]>
  export type studentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_inscription?: boolean | student$student_inscriptionArgs<ExtArgs>
    student_presence?: boolean | student$student_presenceArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type studentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type studentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $studentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student"
    objects: {
      student_inscription: Prisma.$inscriptionPayload<ExtArgs>[]
      student_presence: Prisma.$presencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      first_name: string
      mail: string
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type studentGetPayload<S extends boolean | null | undefined | studentDefaultArgs> = $Result.GetResult<Prisma.$studentPayload, S>

  type studentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface studentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student'], meta: { name: 'student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {studentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentFindUniqueArgs>(args: SelectSubset<T, studentFindUniqueArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentFindUniqueOrThrowArgs>(args: SelectSubset<T, studentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentFindFirstArgs>(args?: SelectSubset<T, studentFindFirstArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentFindFirstOrThrowArgs>(args?: SelectSubset<T, studentFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends studentFindManyArgs>(args?: SelectSubset<T, studentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {studentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends studentCreateArgs>(args: SelectSubset<T, studentCreateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentCreateManyArgs>(args?: SelectSubset<T, studentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {studentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends studentCreateManyAndReturnArgs>(args?: SelectSubset<T, studentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {studentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends studentDeleteArgs>(args: SelectSubset<T, studentDeleteArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {studentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentUpdateArgs>(args: SelectSubset<T, studentUpdateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentDeleteManyArgs>(args?: SelectSubset<T, studentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentUpdateManyArgs>(args: SelectSubset<T, studentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {studentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends studentUpdateManyAndReturnArgs>(args: SelectSubset<T, studentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {studentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends studentUpsertArgs>(args: SelectSubset<T, studentUpsertArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentCountArgs>(
      args?: Subset<T, studentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentGroupByArgs['orderBy'] }
        : { orderBy?: studentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student model
   */
  readonly fields: studentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student_inscription<T extends student$student_inscriptionArgs<ExtArgs> = {}>(args?: Subset<T, student$student_inscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_presence<T extends student$student_presenceArgs<ExtArgs> = {}>(args?: Subset<T, student$student_presenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student model
   */
  interface studentFieldRefs {
    readonly id: FieldRef<"student", 'String'>
    readonly name: FieldRef<"student", 'String'>
    readonly first_name: FieldRef<"student", 'String'>
    readonly mail: FieldRef<"student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * student findUnique
   */
  export type studentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findUniqueOrThrow
   */
  export type studentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findFirst
   */
  export type studentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findFirstOrThrow
   */
  export type studentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findMany
   */
  export type studentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student create
   */
  export type studentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to create a student.
     */
    data: XOR<studentCreateInput, studentUncheckedCreateInput>
  }

  /**
   * student createMany
   */
  export type studentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentCreateManyInput | studentCreateManyInput[]
  }

  /**
   * student createManyAndReturn
   */
  export type studentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * The data used to create many students.
     */
    data: studentCreateManyInput | studentCreateManyInput[]
  }

  /**
   * student update
   */
  export type studentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to update a student.
     */
    data: XOR<studentUpdateInput, studentUncheckedUpdateInput>
    /**
     * Choose, which student to update.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student updateMany
   */
  export type studentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * student updateManyAndReturn
   */
  export type studentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * The data used to update students.
     */
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * student upsert
   */
  export type studentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The filter to search for the student to update in case it exists.
     */
    where: studentWhereUniqueInput
    /**
     * In case the student found by the `where` argument doesn't exist, create a new student with this data.
     */
    create: XOR<studentCreateInput, studentUncheckedCreateInput>
    /**
     * In case the student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentUpdateInput, studentUncheckedUpdateInput>
  }

  /**
   * student delete
   */
  export type studentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter which student to delete.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student deleteMany
   */
  export type studentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * student.student_inscription
   */
  export type student$student_inscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    where?: inscriptionWhereInput
    orderBy?: inscriptionOrderByWithRelationInput | inscriptionOrderByWithRelationInput[]
    cursor?: inscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }

  /**
   * student.student_presence
   */
  export type student$student_presenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    where?: presenceWhereInput
    orderBy?: presenceOrderByWithRelationInput | presenceOrderByWithRelationInput[]
    cursor?: presenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresenceScalarFieldEnum | PresenceScalarFieldEnum[]
  }

  /**
   * student without action
   */
  export type studentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
  }


  /**
   * Model inscription
   */

  export type AggregateInscription = {
    _count: InscriptionCountAggregateOutputType | null
    _min: InscriptionMinAggregateOutputType | null
    _max: InscriptionMaxAggregateOutputType | null
  }

  export type InscriptionMinAggregateOutputType = {
    student_id: string | null
    group_id: string | null
  }

  export type InscriptionMaxAggregateOutputType = {
    student_id: string | null
    group_id: string | null
  }

  export type InscriptionCountAggregateOutputType = {
    student_id: number
    group_id: number
    _all: number
  }


  export type InscriptionMinAggregateInputType = {
    student_id?: true
    group_id?: true
  }

  export type InscriptionMaxAggregateInputType = {
    student_id?: true
    group_id?: true
  }

  export type InscriptionCountAggregateInputType = {
    student_id?: true
    group_id?: true
    _all?: true
  }

  export type InscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inscription to aggregate.
     */
    where?: inscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscriptions to fetch.
     */
    orderBy?: inscriptionOrderByWithRelationInput | inscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inscriptions
    **/
    _count?: true | InscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InscriptionMaxAggregateInputType
  }

  export type GetInscriptionAggregateType<T extends InscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateInscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscription[P]>
      : GetScalarType<T[P], AggregateInscription[P]>
  }




  export type inscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscriptionWhereInput
    orderBy?: inscriptionOrderByWithAggregationInput | inscriptionOrderByWithAggregationInput[]
    by: InscriptionScalarFieldEnum[] | InscriptionScalarFieldEnum
    having?: inscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InscriptionCountAggregateInputType | true
    _min?: InscriptionMinAggregateInputType
    _max?: InscriptionMaxAggregateInputType
  }

  export type InscriptionGroupByOutputType = {
    student_id: string
    group_id: string
    _count: InscriptionCountAggregateOutputType | null
    _min: InscriptionMinAggregateOutputType | null
    _max: InscriptionMaxAggregateOutputType | null
  }

  type GetInscriptionGroupByPayload<T extends inscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], InscriptionGroupByOutputType[P]>
        }
      >
    >


  export type inscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    group_id?: boolean
    inscription_student?: boolean | studentDefaultArgs<ExtArgs>
    inscription_group?: boolean | groupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscription"]>

  export type inscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    group_id?: boolean
    inscription_student?: boolean | studentDefaultArgs<ExtArgs>
    inscription_group?: boolean | groupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscription"]>

  export type inscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    group_id?: boolean
    inscription_student?: boolean | studentDefaultArgs<ExtArgs>
    inscription_group?: boolean | groupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscription"]>

  export type inscriptionSelectScalar = {
    student_id?: boolean
    group_id?: boolean
  }

  export type inscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"student_id" | "group_id", ExtArgs["result"]["inscription"]>
  export type inscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscription_student?: boolean | studentDefaultArgs<ExtArgs>
    inscription_group?: boolean | groupDefaultArgs<ExtArgs>
  }
  export type inscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscription_student?: boolean | studentDefaultArgs<ExtArgs>
    inscription_group?: boolean | groupDefaultArgs<ExtArgs>
  }
  export type inscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inscription_student?: boolean | studentDefaultArgs<ExtArgs>
    inscription_group?: boolean | groupDefaultArgs<ExtArgs>
  }

  export type $inscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inscription"
    objects: {
      inscription_student: Prisma.$studentPayload<ExtArgs>
      inscription_group: Prisma.$groupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      student_id: string
      group_id: string
    }, ExtArgs["result"]["inscription"]>
    composites: {}
  }

  type inscriptionGetPayload<S extends boolean | null | undefined | inscriptionDefaultArgs> = $Result.GetResult<Prisma.$inscriptionPayload, S>

  type inscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InscriptionCountAggregateInputType | true
    }

  export interface inscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inscription'], meta: { name: 'inscription' } }
    /**
     * Find zero or one Inscription that matches the filter.
     * @param {inscriptionFindUniqueArgs} args - Arguments to find a Inscription
     * @example
     * // Get one Inscription
     * const inscription = await prisma.inscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inscriptionFindUniqueArgs>(args: SelectSubset<T, inscriptionFindUniqueArgs<ExtArgs>>): Prisma__inscriptionClient<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inscriptionFindUniqueOrThrowArgs} args - Arguments to find a Inscription
     * @example
     * // Get one Inscription
     * const inscription = await prisma.inscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, inscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inscriptionClient<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscriptionFindFirstArgs} args - Arguments to find a Inscription
     * @example
     * // Get one Inscription
     * const inscription = await prisma.inscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inscriptionFindFirstArgs>(args?: SelectSubset<T, inscriptionFindFirstArgs<ExtArgs>>): Prisma__inscriptionClient<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscriptionFindFirstOrThrowArgs} args - Arguments to find a Inscription
     * @example
     * // Get one Inscription
     * const inscription = await prisma.inscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, inscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__inscriptionClient<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscriptions
     * const inscriptions = await prisma.inscription.findMany()
     * 
     * // Get first 10 Inscriptions
     * const inscriptions = await prisma.inscription.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const inscriptionWithStudent_idOnly = await prisma.inscription.findMany({ select: { student_id: true } })
     * 
     */
    findMany<T extends inscriptionFindManyArgs>(args?: SelectSubset<T, inscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inscription.
     * @param {inscriptionCreateArgs} args - Arguments to create a Inscription.
     * @example
     * // Create one Inscription
     * const Inscription = await prisma.inscription.create({
     *   data: {
     *     // ... data to create a Inscription
     *   }
     * })
     * 
     */
    create<T extends inscriptionCreateArgs>(args: SelectSubset<T, inscriptionCreateArgs<ExtArgs>>): Prisma__inscriptionClient<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inscriptions.
     * @param {inscriptionCreateManyArgs} args - Arguments to create many Inscriptions.
     * @example
     * // Create many Inscriptions
     * const inscription = await prisma.inscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inscriptionCreateManyArgs>(args?: SelectSubset<T, inscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inscriptions and returns the data saved in the database.
     * @param {inscriptionCreateManyAndReturnArgs} args - Arguments to create many Inscriptions.
     * @example
     * // Create many Inscriptions
     * const inscription = await prisma.inscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inscriptions and only return the `student_id`
     * const inscriptionWithStudent_idOnly = await prisma.inscription.createManyAndReturn({
     *   select: { student_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, inscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inscription.
     * @param {inscriptionDeleteArgs} args - Arguments to delete one Inscription.
     * @example
     * // Delete one Inscription
     * const Inscription = await prisma.inscription.delete({
     *   where: {
     *     // ... filter to delete one Inscription
     *   }
     * })
     * 
     */
    delete<T extends inscriptionDeleteArgs>(args: SelectSubset<T, inscriptionDeleteArgs<ExtArgs>>): Prisma__inscriptionClient<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inscription.
     * @param {inscriptionUpdateArgs} args - Arguments to update one Inscription.
     * @example
     * // Update one Inscription
     * const inscription = await prisma.inscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inscriptionUpdateArgs>(args: SelectSubset<T, inscriptionUpdateArgs<ExtArgs>>): Prisma__inscriptionClient<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inscriptions.
     * @param {inscriptionDeleteManyArgs} args - Arguments to filter Inscriptions to delete.
     * @example
     * // Delete a few Inscriptions
     * const { count } = await prisma.inscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inscriptionDeleteManyArgs>(args?: SelectSubset<T, inscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscriptions
     * const inscription = await prisma.inscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inscriptionUpdateManyArgs>(args: SelectSubset<T, inscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscriptions and returns the data updated in the database.
     * @param {inscriptionUpdateManyAndReturnArgs} args - Arguments to update many Inscriptions.
     * @example
     * // Update many Inscriptions
     * const inscription = await prisma.inscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inscriptions and only return the `student_id`
     * const inscriptionWithStudent_idOnly = await prisma.inscription.updateManyAndReturn({
     *   select: { student_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, inscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inscription.
     * @param {inscriptionUpsertArgs} args - Arguments to update or create a Inscription.
     * @example
     * // Update or create a Inscription
     * const inscription = await prisma.inscription.upsert({
     *   create: {
     *     // ... data to create a Inscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscription we want to update
     *   }
     * })
     */
    upsert<T extends inscriptionUpsertArgs>(args: SelectSubset<T, inscriptionUpsertArgs<ExtArgs>>): Prisma__inscriptionClient<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscriptionCountArgs} args - Arguments to filter Inscriptions to count.
     * @example
     * // Count the number of Inscriptions
     * const count = await prisma.inscription.count({
     *   where: {
     *     // ... the filter for the Inscriptions we want to count
     *   }
     * })
    **/
    count<T extends inscriptionCountArgs>(
      args?: Subset<T, inscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InscriptionAggregateArgs>(args: Subset<T, InscriptionAggregateArgs>): Prisma.PrismaPromise<GetInscriptionAggregateType<T>>

    /**
     * Group by Inscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inscriptionGroupByArgs['orderBy'] }
        : { orderBy?: inscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inscription model
   */
  readonly fields: inscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inscription_student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inscription_group<T extends groupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupDefaultArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inscription model
   */
  interface inscriptionFieldRefs {
    readonly student_id: FieldRef<"inscription", 'String'>
    readonly group_id: FieldRef<"inscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * inscription findUnique
   */
  export type inscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * Filter, which inscription to fetch.
     */
    where: inscriptionWhereUniqueInput
  }

  /**
   * inscription findUniqueOrThrow
   */
  export type inscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * Filter, which inscription to fetch.
     */
    where: inscriptionWhereUniqueInput
  }

  /**
   * inscription findFirst
   */
  export type inscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * Filter, which inscription to fetch.
     */
    where?: inscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscriptions to fetch.
     */
    orderBy?: inscriptionOrderByWithRelationInput | inscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inscriptions.
     */
    cursor?: inscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inscriptions.
     */
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }

  /**
   * inscription findFirstOrThrow
   */
  export type inscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * Filter, which inscription to fetch.
     */
    where?: inscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscriptions to fetch.
     */
    orderBy?: inscriptionOrderByWithRelationInput | inscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inscriptions.
     */
    cursor?: inscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inscriptions.
     */
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }

  /**
   * inscription findMany
   */
  export type inscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * Filter, which inscriptions to fetch.
     */
    where?: inscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscriptions to fetch.
     */
    orderBy?: inscriptionOrderByWithRelationInput | inscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inscriptions.
     */
    cursor?: inscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscriptions.
     */
    skip?: number
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }

  /**
   * inscription create
   */
  export type inscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a inscription.
     */
    data: XOR<inscriptionCreateInput, inscriptionUncheckedCreateInput>
  }

  /**
   * inscription createMany
   */
  export type inscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inscriptions.
     */
    data: inscriptionCreateManyInput | inscriptionCreateManyInput[]
  }

  /**
   * inscription createManyAndReturn
   */
  export type inscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many inscriptions.
     */
    data: inscriptionCreateManyInput | inscriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inscription update
   */
  export type inscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a inscription.
     */
    data: XOR<inscriptionUpdateInput, inscriptionUncheckedUpdateInput>
    /**
     * Choose, which inscription to update.
     */
    where: inscriptionWhereUniqueInput
  }

  /**
   * inscription updateMany
   */
  export type inscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inscriptions.
     */
    data: XOR<inscriptionUpdateManyMutationInput, inscriptionUncheckedUpdateManyInput>
    /**
     * Filter which inscriptions to update
     */
    where?: inscriptionWhereInput
    /**
     * Limit how many inscriptions to update.
     */
    limit?: number
  }

  /**
   * inscription updateManyAndReturn
   */
  export type inscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * The data used to update inscriptions.
     */
    data: XOR<inscriptionUpdateManyMutationInput, inscriptionUncheckedUpdateManyInput>
    /**
     * Filter which inscriptions to update
     */
    where?: inscriptionWhereInput
    /**
     * Limit how many inscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * inscription upsert
   */
  export type inscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the inscription to update in case it exists.
     */
    where: inscriptionWhereUniqueInput
    /**
     * In case the inscription found by the `where` argument doesn't exist, create a new inscription with this data.
     */
    create: XOR<inscriptionCreateInput, inscriptionUncheckedCreateInput>
    /**
     * In case the inscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inscriptionUpdateInput, inscriptionUncheckedUpdateInput>
  }

  /**
   * inscription delete
   */
  export type inscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    /**
     * Filter which inscription to delete.
     */
    where: inscriptionWhereUniqueInput
  }

  /**
   * inscription deleteMany
   */
  export type inscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inscriptions to delete
     */
    where?: inscriptionWhereInput
    /**
     * Limit how many inscriptions to delete.
     */
    limit?: number
  }

  /**
   * inscription without action
   */
  export type inscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
  }


  /**
   * Model group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    semester_id: string | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    semester_id: string | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    semester_id: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    semester_id?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    semester_id?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    semester_id?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group to aggregate.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type groupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupWhereInput
    orderBy?: groupOrderByWithAggregationInput | groupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    semester_id: string
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type groupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    semester_id?: boolean
    group_semester?: boolean | semesterDefaultArgs<ExtArgs>
    group_inscription?: boolean | group$group_inscriptionArgs<ExtArgs>
    group_slot?: boolean | group$group_slotArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type groupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    semester_id?: boolean
    group_semester?: boolean | semesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type groupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    semester_id?: boolean
    group_semester?: boolean | semesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type groupSelectScalar = {
    id?: boolean
    name?: boolean
    semester_id?: boolean
  }

  export type groupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "semester_id", ExtArgs["result"]["group"]>
  export type groupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_semester?: boolean | semesterDefaultArgs<ExtArgs>
    group_inscription?: boolean | group$group_inscriptionArgs<ExtArgs>
    group_slot?: boolean | group$group_slotArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type groupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_semester?: boolean | semesterDefaultArgs<ExtArgs>
  }
  export type groupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group_semester?: boolean | semesterDefaultArgs<ExtArgs>
  }

  export type $groupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group"
    objects: {
      group_semester: Prisma.$semesterPayload<ExtArgs>
      group_inscription: Prisma.$inscriptionPayload<ExtArgs>[]
      group_slot: Prisma.$slotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      semester_id: string
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type groupGetPayload<S extends boolean | null | undefined | groupDefaultArgs> = $Result.GetResult<Prisma.$groupPayload, S>

  type groupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<groupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface groupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group'], meta: { name: 'group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {groupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends groupFindUniqueArgs>(args: SelectSubset<T, groupFindUniqueArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {groupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends groupFindUniqueOrThrowArgs>(args: SelectSubset<T, groupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends groupFindFirstArgs>(args?: SelectSubset<T, groupFindFirstArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends groupFindFirstOrThrowArgs>(args?: SelectSubset<T, groupFindFirstOrThrowArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends groupFindManyArgs>(args?: SelectSubset<T, groupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {groupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends groupCreateArgs>(args: SelectSubset<T, groupCreateArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {groupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends groupCreateManyArgs>(args?: SelectSubset<T, groupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {groupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends groupCreateManyAndReturnArgs>(args?: SelectSubset<T, groupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {groupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends groupDeleteArgs>(args: SelectSubset<T, groupDeleteArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {groupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends groupUpdateArgs>(args: SelectSubset<T, groupUpdateArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {groupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends groupDeleteManyArgs>(args?: SelectSubset<T, groupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends groupUpdateManyArgs>(args: SelectSubset<T, groupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {groupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends groupUpdateManyAndReturnArgs>(args: SelectSubset<T, groupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {groupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends groupUpsertArgs>(args: SelectSubset<T, groupUpsertArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends groupCountArgs>(
      args?: Subset<T, groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupGroupByArgs['orderBy'] }
        : { orderBy?: groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group model
   */
  readonly fields: groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group_semester<T extends semesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, semesterDefaultArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group_inscription<T extends group$group_inscriptionArgs<ExtArgs> = {}>(args?: Subset<T, group$group_inscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    group_slot<T extends group$group_slotArgs<ExtArgs> = {}>(args?: Subset<T, group$group_slotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group model
   */
  interface groupFieldRefs {
    readonly id: FieldRef<"group", 'String'>
    readonly name: FieldRef<"group", 'String'>
    readonly semester_id: FieldRef<"group", 'String'>
  }
    

  // Custom InputTypes
  /**
   * group findUnique
   */
  export type groupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group findUniqueOrThrow
   */
  export type groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group findFirst
   */
  export type groupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group findFirstOrThrow
   */
  export type groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group findMany
   */
  export type groupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group create
   */
  export type groupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The data needed to create a group.
     */
    data: XOR<groupCreateInput, groupUncheckedCreateInput>
  }

  /**
   * group createMany
   */
  export type groupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groups.
     */
    data: groupCreateManyInput | groupCreateManyInput[]
  }

  /**
   * group createManyAndReturn
   */
  export type groupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * The data used to create many groups.
     */
    data: groupCreateManyInput | groupCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * group update
   */
  export type groupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The data needed to update a group.
     */
    data: XOR<groupUpdateInput, groupUncheckedUpdateInput>
    /**
     * Choose, which group to update.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group updateMany
   */
  export type groupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groups.
     */
    data: XOR<groupUpdateManyMutationInput, groupUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupWhereInput
    /**
     * Limit how many groups to update.
     */
    limit?: number
  }

  /**
   * group updateManyAndReturn
   */
  export type groupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * The data used to update groups.
     */
    data: XOR<groupUpdateManyMutationInput, groupUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupWhereInput
    /**
     * Limit how many groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * group upsert
   */
  export type groupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The filter to search for the group to update in case it exists.
     */
    where: groupWhereUniqueInput
    /**
     * In case the group found by the `where` argument doesn't exist, create a new group with this data.
     */
    create: XOR<groupCreateInput, groupUncheckedCreateInput>
    /**
     * In case the group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupUpdateInput, groupUncheckedUpdateInput>
  }

  /**
   * group delete
   */
  export type groupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter which group to delete.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group deleteMany
   */
  export type groupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to delete
     */
    where?: groupWhereInput
    /**
     * Limit how many groups to delete.
     */
    limit?: number
  }

  /**
   * group.group_inscription
   */
  export type group$group_inscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscription
     */
    select?: inscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscription
     */
    omit?: inscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscriptionInclude<ExtArgs> | null
    where?: inscriptionWhereInput
    orderBy?: inscriptionOrderByWithRelationInput | inscriptionOrderByWithRelationInput[]
    cursor?: inscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscriptionScalarFieldEnum | InscriptionScalarFieldEnum[]
  }

  /**
   * group.group_slot
   */
  export type group$group_slotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    where?: slotWhereInput
    orderBy?: slotOrderByWithRelationInput | slotOrderByWithRelationInput[]
    cursor?: slotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * group without action
   */
  export type groupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
  }


  /**
   * Model semester
   */

  export type AggregateSemester = {
    _count: SemesterCountAggregateOutputType | null
    _min: SemesterMinAggregateOutputType | null
    _max: SemesterMaxAggregateOutputType | null
  }

  export type SemesterMinAggregateOutputType = {
    id: string | null
    year: Date | null
    name: string | null
  }

  export type SemesterMaxAggregateOutputType = {
    id: string | null
    year: Date | null
    name: string | null
  }

  export type SemesterCountAggregateOutputType = {
    id: number
    year: number
    name: number
    _all: number
  }


  export type SemesterMinAggregateInputType = {
    id?: true
    year?: true
    name?: true
  }

  export type SemesterMaxAggregateInputType = {
    id?: true
    year?: true
    name?: true
  }

  export type SemesterCountAggregateInputType = {
    id?: true
    year?: true
    name?: true
    _all?: true
  }

  export type SemesterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which semester to aggregate.
     */
    where?: semesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semesters to fetch.
     */
    orderBy?: semesterOrderByWithRelationInput | semesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: semesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned semesters
    **/
    _count?: true | SemesterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemesterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemesterMaxAggregateInputType
  }

  export type GetSemesterAggregateType<T extends SemesterAggregateArgs> = {
        [P in keyof T & keyof AggregateSemester]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemester[P]>
      : GetScalarType<T[P], AggregateSemester[P]>
  }




  export type semesterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: semesterWhereInput
    orderBy?: semesterOrderByWithAggregationInput | semesterOrderByWithAggregationInput[]
    by: SemesterScalarFieldEnum[] | SemesterScalarFieldEnum
    having?: semesterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemesterCountAggregateInputType | true
    _min?: SemesterMinAggregateInputType
    _max?: SemesterMaxAggregateInputType
  }

  export type SemesterGroupByOutputType = {
    id: string
    year: Date
    name: string
    _count: SemesterCountAggregateOutputType | null
    _min: SemesterMinAggregateOutputType | null
    _max: SemesterMaxAggregateOutputType | null
  }

  type GetSemesterGroupByPayload<T extends semesterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemesterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemesterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemesterGroupByOutputType[P]>
            : GetScalarType<T[P], SemesterGroupByOutputType[P]>
        }
      >
    >


  export type semesterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    name?: boolean
    semester_group?: boolean | semester$semester_groupArgs<ExtArgs>
    semester_course_material?: boolean | semester$semester_course_materialArgs<ExtArgs>
    _count?: boolean | SemesterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semester"]>

  export type semesterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    name?: boolean
  }, ExtArgs["result"]["semester"]>

  export type semesterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    name?: boolean
  }, ExtArgs["result"]["semester"]>

  export type semesterSelectScalar = {
    id?: boolean
    year?: boolean
    name?: boolean
  }

  export type semesterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "name", ExtArgs["result"]["semester"]>
  export type semesterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semester_group?: boolean | semester$semester_groupArgs<ExtArgs>
    semester_course_material?: boolean | semester$semester_course_materialArgs<ExtArgs>
    _count?: boolean | SemesterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type semesterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type semesterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $semesterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "semester"
    objects: {
      semester_group: Prisma.$groupPayload<ExtArgs>[]
      semester_course_material: Prisma.$course_materialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: Date
      name: string
    }, ExtArgs["result"]["semester"]>
    composites: {}
  }

  type semesterGetPayload<S extends boolean | null | undefined | semesterDefaultArgs> = $Result.GetResult<Prisma.$semesterPayload, S>

  type semesterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<semesterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SemesterCountAggregateInputType | true
    }

  export interface semesterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['semester'], meta: { name: 'semester' } }
    /**
     * Find zero or one Semester that matches the filter.
     * @param {semesterFindUniqueArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends semesterFindUniqueArgs>(args: SelectSubset<T, semesterFindUniqueArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Semester that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {semesterFindUniqueOrThrowArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends semesterFindUniqueOrThrowArgs>(args: SelectSubset<T, semesterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Semester that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semesterFindFirstArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends semesterFindFirstArgs>(args?: SelectSubset<T, semesterFindFirstArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Semester that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semesterFindFirstOrThrowArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends semesterFindFirstOrThrowArgs>(args?: SelectSubset<T, semesterFindFirstOrThrowArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Semesters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semesterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Semesters
     * const semesters = await prisma.semester.findMany()
     * 
     * // Get first 10 Semesters
     * const semesters = await prisma.semester.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semesterWithIdOnly = await prisma.semester.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends semesterFindManyArgs>(args?: SelectSubset<T, semesterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Semester.
     * @param {semesterCreateArgs} args - Arguments to create a Semester.
     * @example
     * // Create one Semester
     * const Semester = await prisma.semester.create({
     *   data: {
     *     // ... data to create a Semester
     *   }
     * })
     * 
     */
    create<T extends semesterCreateArgs>(args: SelectSubset<T, semesterCreateArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Semesters.
     * @param {semesterCreateManyArgs} args - Arguments to create many Semesters.
     * @example
     * // Create many Semesters
     * const semester = await prisma.semester.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends semesterCreateManyArgs>(args?: SelectSubset<T, semesterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Semesters and returns the data saved in the database.
     * @param {semesterCreateManyAndReturnArgs} args - Arguments to create many Semesters.
     * @example
     * // Create many Semesters
     * const semester = await prisma.semester.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Semesters and only return the `id`
     * const semesterWithIdOnly = await prisma.semester.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends semesterCreateManyAndReturnArgs>(args?: SelectSubset<T, semesterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Semester.
     * @param {semesterDeleteArgs} args - Arguments to delete one Semester.
     * @example
     * // Delete one Semester
     * const Semester = await prisma.semester.delete({
     *   where: {
     *     // ... filter to delete one Semester
     *   }
     * })
     * 
     */
    delete<T extends semesterDeleteArgs>(args: SelectSubset<T, semesterDeleteArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Semester.
     * @param {semesterUpdateArgs} args - Arguments to update one Semester.
     * @example
     * // Update one Semester
     * const semester = await prisma.semester.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends semesterUpdateArgs>(args: SelectSubset<T, semesterUpdateArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Semesters.
     * @param {semesterDeleteManyArgs} args - Arguments to filter Semesters to delete.
     * @example
     * // Delete a few Semesters
     * const { count } = await prisma.semester.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends semesterDeleteManyArgs>(args?: SelectSubset<T, semesterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semesterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Semesters
     * const semester = await prisma.semester.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends semesterUpdateManyArgs>(args: SelectSubset<T, semesterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semesters and returns the data updated in the database.
     * @param {semesterUpdateManyAndReturnArgs} args - Arguments to update many Semesters.
     * @example
     * // Update many Semesters
     * const semester = await prisma.semester.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Semesters and only return the `id`
     * const semesterWithIdOnly = await prisma.semester.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends semesterUpdateManyAndReturnArgs>(args: SelectSubset<T, semesterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Semester.
     * @param {semesterUpsertArgs} args - Arguments to update or create a Semester.
     * @example
     * // Update or create a Semester
     * const semester = await prisma.semester.upsert({
     *   create: {
     *     // ... data to create a Semester
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Semester we want to update
     *   }
     * })
     */
    upsert<T extends semesterUpsertArgs>(args: SelectSubset<T, semesterUpsertArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semesterCountArgs} args - Arguments to filter Semesters to count.
     * @example
     * // Count the number of Semesters
     * const count = await prisma.semester.count({
     *   where: {
     *     // ... the filter for the Semesters we want to count
     *   }
     * })
    **/
    count<T extends semesterCountArgs>(
      args?: Subset<T, semesterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemesterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Semester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemesterAggregateArgs>(args: Subset<T, SemesterAggregateArgs>): Prisma.PrismaPromise<GetSemesterAggregateType<T>>

    /**
     * Group by Semester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semesterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends semesterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: semesterGroupByArgs['orderBy'] }
        : { orderBy?: semesterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, semesterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemesterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the semester model
   */
  readonly fields: semesterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for semester.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__semesterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    semester_group<T extends semester$semester_groupArgs<ExtArgs> = {}>(args?: Subset<T, semester$semester_groupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    semester_course_material<T extends semester$semester_course_materialArgs<ExtArgs> = {}>(args?: Subset<T, semester$semester_course_materialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the semester model
   */
  interface semesterFieldRefs {
    readonly id: FieldRef<"semester", 'String'>
    readonly year: FieldRef<"semester", 'DateTime'>
    readonly name: FieldRef<"semester", 'String'>
  }
    

  // Custom InputTypes
  /**
   * semester findUnique
   */
  export type semesterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * Filter, which semester to fetch.
     */
    where: semesterWhereUniqueInput
  }

  /**
   * semester findUniqueOrThrow
   */
  export type semesterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * Filter, which semester to fetch.
     */
    where: semesterWhereUniqueInput
  }

  /**
   * semester findFirst
   */
  export type semesterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * Filter, which semester to fetch.
     */
    where?: semesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semesters to fetch.
     */
    orderBy?: semesterOrderByWithRelationInput | semesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for semesters.
     */
    cursor?: semesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of semesters.
     */
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * semester findFirstOrThrow
   */
  export type semesterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * Filter, which semester to fetch.
     */
    where?: semesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semesters to fetch.
     */
    orderBy?: semesterOrderByWithRelationInput | semesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for semesters.
     */
    cursor?: semesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of semesters.
     */
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * semester findMany
   */
  export type semesterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * Filter, which semesters to fetch.
     */
    where?: semesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semesters to fetch.
     */
    orderBy?: semesterOrderByWithRelationInput | semesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing semesters.
     */
    cursor?: semesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semesters.
     */
    skip?: number
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * semester create
   */
  export type semesterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * The data needed to create a semester.
     */
    data: XOR<semesterCreateInput, semesterUncheckedCreateInput>
  }

  /**
   * semester createMany
   */
  export type semesterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many semesters.
     */
    data: semesterCreateManyInput | semesterCreateManyInput[]
  }

  /**
   * semester createManyAndReturn
   */
  export type semesterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * The data used to create many semesters.
     */
    data: semesterCreateManyInput | semesterCreateManyInput[]
  }

  /**
   * semester update
   */
  export type semesterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * The data needed to update a semester.
     */
    data: XOR<semesterUpdateInput, semesterUncheckedUpdateInput>
    /**
     * Choose, which semester to update.
     */
    where: semesterWhereUniqueInput
  }

  /**
   * semester updateMany
   */
  export type semesterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update semesters.
     */
    data: XOR<semesterUpdateManyMutationInput, semesterUncheckedUpdateManyInput>
    /**
     * Filter which semesters to update
     */
    where?: semesterWhereInput
    /**
     * Limit how many semesters to update.
     */
    limit?: number
  }

  /**
   * semester updateManyAndReturn
   */
  export type semesterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * The data used to update semesters.
     */
    data: XOR<semesterUpdateManyMutationInput, semesterUncheckedUpdateManyInput>
    /**
     * Filter which semesters to update
     */
    where?: semesterWhereInput
    /**
     * Limit how many semesters to update.
     */
    limit?: number
  }

  /**
   * semester upsert
   */
  export type semesterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * The filter to search for the semester to update in case it exists.
     */
    where: semesterWhereUniqueInput
    /**
     * In case the semester found by the `where` argument doesn't exist, create a new semester with this data.
     */
    create: XOR<semesterCreateInput, semesterUncheckedCreateInput>
    /**
     * In case the semester was found with the provided `where` argument, update it with this data.
     */
    update: XOR<semesterUpdateInput, semesterUncheckedUpdateInput>
  }

  /**
   * semester delete
   */
  export type semesterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
    /**
     * Filter which semester to delete.
     */
    where: semesterWhereUniqueInput
  }

  /**
   * semester deleteMany
   */
  export type semesterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which semesters to delete
     */
    where?: semesterWhereInput
    /**
     * Limit how many semesters to delete.
     */
    limit?: number
  }

  /**
   * semester.semester_group
   */
  export type semester$semester_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the group
     */
    omit?: groupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    where?: groupWhereInput
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    cursor?: groupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * semester.semester_course_material
   */
  export type semester$semester_course_materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    where?: course_materialWhereInput
    orderBy?: course_materialOrderByWithRelationInput | course_materialOrderByWithRelationInput[]
    cursor?: course_materialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Course_materialScalarFieldEnum | Course_materialScalarFieldEnum[]
  }

  /**
   * semester without action
   */
  export type semesterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semester
     */
    select?: semesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semester
     */
    omit?: semesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semesterInclude<ExtArgs> | null
  }


  /**
   * Model course_material
   */

  export type AggregateCourse_material = {
    _count: Course_materialCountAggregateOutputType | null
    _min: Course_materialMinAggregateOutputType | null
    _max: Course_materialMaxAggregateOutputType | null
  }

  export type Course_materialMinAggregateOutputType = {
    id: string | null
    name: string | null
    semester_id: string | null
  }

  export type Course_materialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    semester_id: string | null
  }

  export type Course_materialCountAggregateOutputType = {
    id: number
    name: number
    semester_id: number
    _all: number
  }


  export type Course_materialMinAggregateInputType = {
    id?: true
    name?: true
    semester_id?: true
  }

  export type Course_materialMaxAggregateInputType = {
    id?: true
    name?: true
    semester_id?: true
  }

  export type Course_materialCountAggregateInputType = {
    id?: true
    name?: true
    semester_id?: true
    _all?: true
  }

  export type Course_materialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course_material to aggregate.
     */
    where?: course_materialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_materials to fetch.
     */
    orderBy?: course_materialOrderByWithRelationInput | course_materialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: course_materialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned course_materials
    **/
    _count?: true | Course_materialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Course_materialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Course_materialMaxAggregateInputType
  }

  export type GetCourse_materialAggregateType<T extends Course_materialAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse_material]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse_material[P]>
      : GetScalarType<T[P], AggregateCourse_material[P]>
  }




  export type course_materialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_materialWhereInput
    orderBy?: course_materialOrderByWithAggregationInput | course_materialOrderByWithAggregationInput[]
    by: Course_materialScalarFieldEnum[] | Course_materialScalarFieldEnum
    having?: course_materialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Course_materialCountAggregateInputType | true
    _min?: Course_materialMinAggregateInputType
    _max?: Course_materialMaxAggregateInputType
  }

  export type Course_materialGroupByOutputType = {
    id: string
    name: string
    semester_id: string
    _count: Course_materialCountAggregateOutputType | null
    _min: Course_materialMinAggregateOutputType | null
    _max: Course_materialMaxAggregateOutputType | null
  }

  type GetCourse_materialGroupByPayload<T extends course_materialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Course_materialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Course_materialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Course_materialGroupByOutputType[P]>
            : GetScalarType<T[P], Course_materialGroupByOutputType[P]>
        }
      >
    >


  export type course_materialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    semester_id?: boolean
    course_material_semester?: boolean | semesterDefaultArgs<ExtArgs>
    course_material_session_type?: boolean | course_material$course_material_session_typeArgs<ExtArgs>
    _count?: boolean | Course_materialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course_material"]>

  export type course_materialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    semester_id?: boolean
    course_material_semester?: boolean | semesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course_material"]>

  export type course_materialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    semester_id?: boolean
    course_material_semester?: boolean | semesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course_material"]>

  export type course_materialSelectScalar = {
    id?: boolean
    name?: boolean
    semester_id?: boolean
  }

  export type course_materialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "semester_id", ExtArgs["result"]["course_material"]>
  export type course_materialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_material_semester?: boolean | semesterDefaultArgs<ExtArgs>
    course_material_session_type?: boolean | course_material$course_material_session_typeArgs<ExtArgs>
    _count?: boolean | Course_materialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type course_materialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_material_semester?: boolean | semesterDefaultArgs<ExtArgs>
  }
  export type course_materialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_material_semester?: boolean | semesterDefaultArgs<ExtArgs>
  }

  export type $course_materialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "course_material"
    objects: {
      course_material_semester: Prisma.$semesterPayload<ExtArgs>
      course_material_session_type: Prisma.$session_typePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      semester_id: string
    }, ExtArgs["result"]["course_material"]>
    composites: {}
  }

  type course_materialGetPayload<S extends boolean | null | undefined | course_materialDefaultArgs> = $Result.GetResult<Prisma.$course_materialPayload, S>

  type course_materialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<course_materialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Course_materialCountAggregateInputType | true
    }

  export interface course_materialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['course_material'], meta: { name: 'course_material' } }
    /**
     * Find zero or one Course_material that matches the filter.
     * @param {course_materialFindUniqueArgs} args - Arguments to find a Course_material
     * @example
     * // Get one Course_material
     * const course_material = await prisma.course_material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends course_materialFindUniqueArgs>(args: SelectSubset<T, course_materialFindUniqueArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course_material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {course_materialFindUniqueOrThrowArgs} args - Arguments to find a Course_material
     * @example
     * // Get one Course_material
     * const course_material = await prisma.course_material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends course_materialFindUniqueOrThrowArgs>(args: SelectSubset<T, course_materialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course_material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_materialFindFirstArgs} args - Arguments to find a Course_material
     * @example
     * // Get one Course_material
     * const course_material = await prisma.course_material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends course_materialFindFirstArgs>(args?: SelectSubset<T, course_materialFindFirstArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course_material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_materialFindFirstOrThrowArgs} args - Arguments to find a Course_material
     * @example
     * // Get one Course_material
     * const course_material = await prisma.course_material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends course_materialFindFirstOrThrowArgs>(args?: SelectSubset<T, course_materialFindFirstOrThrowArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Course_materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_materialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Course_materials
     * const course_materials = await prisma.course_material.findMany()
     * 
     * // Get first 10 Course_materials
     * const course_materials = await prisma.course_material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const course_materialWithIdOnly = await prisma.course_material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends course_materialFindManyArgs>(args?: SelectSubset<T, course_materialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course_material.
     * @param {course_materialCreateArgs} args - Arguments to create a Course_material.
     * @example
     * // Create one Course_material
     * const Course_material = await prisma.course_material.create({
     *   data: {
     *     // ... data to create a Course_material
     *   }
     * })
     * 
     */
    create<T extends course_materialCreateArgs>(args: SelectSubset<T, course_materialCreateArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Course_materials.
     * @param {course_materialCreateManyArgs} args - Arguments to create many Course_materials.
     * @example
     * // Create many Course_materials
     * const course_material = await prisma.course_material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends course_materialCreateManyArgs>(args?: SelectSubset<T, course_materialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Course_materials and returns the data saved in the database.
     * @param {course_materialCreateManyAndReturnArgs} args - Arguments to create many Course_materials.
     * @example
     * // Create many Course_materials
     * const course_material = await prisma.course_material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Course_materials and only return the `id`
     * const course_materialWithIdOnly = await prisma.course_material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends course_materialCreateManyAndReturnArgs>(args?: SelectSubset<T, course_materialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course_material.
     * @param {course_materialDeleteArgs} args - Arguments to delete one Course_material.
     * @example
     * // Delete one Course_material
     * const Course_material = await prisma.course_material.delete({
     *   where: {
     *     // ... filter to delete one Course_material
     *   }
     * })
     * 
     */
    delete<T extends course_materialDeleteArgs>(args: SelectSubset<T, course_materialDeleteArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course_material.
     * @param {course_materialUpdateArgs} args - Arguments to update one Course_material.
     * @example
     * // Update one Course_material
     * const course_material = await prisma.course_material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends course_materialUpdateArgs>(args: SelectSubset<T, course_materialUpdateArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Course_materials.
     * @param {course_materialDeleteManyArgs} args - Arguments to filter Course_materials to delete.
     * @example
     * // Delete a few Course_materials
     * const { count } = await prisma.course_material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends course_materialDeleteManyArgs>(args?: SelectSubset<T, course_materialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Course_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_materialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Course_materials
     * const course_material = await prisma.course_material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends course_materialUpdateManyArgs>(args: SelectSubset<T, course_materialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Course_materials and returns the data updated in the database.
     * @param {course_materialUpdateManyAndReturnArgs} args - Arguments to update many Course_materials.
     * @example
     * // Update many Course_materials
     * const course_material = await prisma.course_material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Course_materials and only return the `id`
     * const course_materialWithIdOnly = await prisma.course_material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends course_materialUpdateManyAndReturnArgs>(args: SelectSubset<T, course_materialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course_material.
     * @param {course_materialUpsertArgs} args - Arguments to update or create a Course_material.
     * @example
     * // Update or create a Course_material
     * const course_material = await prisma.course_material.upsert({
     *   create: {
     *     // ... data to create a Course_material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course_material we want to update
     *   }
     * })
     */
    upsert<T extends course_materialUpsertArgs>(args: SelectSubset<T, course_materialUpsertArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Course_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_materialCountArgs} args - Arguments to filter Course_materials to count.
     * @example
     * // Count the number of Course_materials
     * const count = await prisma.course_material.count({
     *   where: {
     *     // ... the filter for the Course_materials we want to count
     *   }
     * })
    **/
    count<T extends course_materialCountArgs>(
      args?: Subset<T, course_materialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Course_materialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course_material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Course_materialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Course_materialAggregateArgs>(args: Subset<T, Course_materialAggregateArgs>): Prisma.PrismaPromise<GetCourse_materialAggregateType<T>>

    /**
     * Group by Course_material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_materialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends course_materialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: course_materialGroupByArgs['orderBy'] }
        : { orderBy?: course_materialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, course_materialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourse_materialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the course_material model
   */
  readonly fields: course_materialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for course_material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__course_materialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course_material_semester<T extends semesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, semesterDefaultArgs<ExtArgs>>): Prisma__semesterClient<$Result.GetResult<Prisma.$semesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course_material_session_type<T extends course_material$course_material_session_typeArgs<ExtArgs> = {}>(args?: Subset<T, course_material$course_material_session_typeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the course_material model
   */
  interface course_materialFieldRefs {
    readonly id: FieldRef<"course_material", 'String'>
    readonly name: FieldRef<"course_material", 'String'>
    readonly semester_id: FieldRef<"course_material", 'String'>
  }
    

  // Custom InputTypes
  /**
   * course_material findUnique
   */
  export type course_materialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * Filter, which course_material to fetch.
     */
    where: course_materialWhereUniqueInput
  }

  /**
   * course_material findUniqueOrThrow
   */
  export type course_materialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * Filter, which course_material to fetch.
     */
    where: course_materialWhereUniqueInput
  }

  /**
   * course_material findFirst
   */
  export type course_materialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * Filter, which course_material to fetch.
     */
    where?: course_materialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_materials to fetch.
     */
    orderBy?: course_materialOrderByWithRelationInput | course_materialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for course_materials.
     */
    cursor?: course_materialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of course_materials.
     */
    distinct?: Course_materialScalarFieldEnum | Course_materialScalarFieldEnum[]
  }

  /**
   * course_material findFirstOrThrow
   */
  export type course_materialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * Filter, which course_material to fetch.
     */
    where?: course_materialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_materials to fetch.
     */
    orderBy?: course_materialOrderByWithRelationInput | course_materialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for course_materials.
     */
    cursor?: course_materialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of course_materials.
     */
    distinct?: Course_materialScalarFieldEnum | Course_materialScalarFieldEnum[]
  }

  /**
   * course_material findMany
   */
  export type course_materialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * Filter, which course_materials to fetch.
     */
    where?: course_materialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_materials to fetch.
     */
    orderBy?: course_materialOrderByWithRelationInput | course_materialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing course_materials.
     */
    cursor?: course_materialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_materials.
     */
    skip?: number
    distinct?: Course_materialScalarFieldEnum | Course_materialScalarFieldEnum[]
  }

  /**
   * course_material create
   */
  export type course_materialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * The data needed to create a course_material.
     */
    data: XOR<course_materialCreateInput, course_materialUncheckedCreateInput>
  }

  /**
   * course_material createMany
   */
  export type course_materialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many course_materials.
     */
    data: course_materialCreateManyInput | course_materialCreateManyInput[]
  }

  /**
   * course_material createManyAndReturn
   */
  export type course_materialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * The data used to create many course_materials.
     */
    data: course_materialCreateManyInput | course_materialCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * course_material update
   */
  export type course_materialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * The data needed to update a course_material.
     */
    data: XOR<course_materialUpdateInput, course_materialUncheckedUpdateInput>
    /**
     * Choose, which course_material to update.
     */
    where: course_materialWhereUniqueInput
  }

  /**
   * course_material updateMany
   */
  export type course_materialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update course_materials.
     */
    data: XOR<course_materialUpdateManyMutationInput, course_materialUncheckedUpdateManyInput>
    /**
     * Filter which course_materials to update
     */
    where?: course_materialWhereInput
    /**
     * Limit how many course_materials to update.
     */
    limit?: number
  }

  /**
   * course_material updateManyAndReturn
   */
  export type course_materialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * The data used to update course_materials.
     */
    data: XOR<course_materialUpdateManyMutationInput, course_materialUncheckedUpdateManyInput>
    /**
     * Filter which course_materials to update
     */
    where?: course_materialWhereInput
    /**
     * Limit how many course_materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * course_material upsert
   */
  export type course_materialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * The filter to search for the course_material to update in case it exists.
     */
    where: course_materialWhereUniqueInput
    /**
     * In case the course_material found by the `where` argument doesn't exist, create a new course_material with this data.
     */
    create: XOR<course_materialCreateInput, course_materialUncheckedCreateInput>
    /**
     * In case the course_material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<course_materialUpdateInput, course_materialUncheckedUpdateInput>
  }

  /**
   * course_material delete
   */
  export type course_materialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
    /**
     * Filter which course_material to delete.
     */
    where: course_materialWhereUniqueInput
  }

  /**
   * course_material deleteMany
   */
  export type course_materialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course_materials to delete
     */
    where?: course_materialWhereInput
    /**
     * Limit how many course_materials to delete.
     */
    limit?: number
  }

  /**
   * course_material.course_material_session_type
   */
  export type course_material$course_material_session_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    where?: session_typeWhereInput
    orderBy?: session_typeOrderByWithRelationInput | session_typeOrderByWithRelationInput[]
    cursor?: session_typeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_typeScalarFieldEnum | Session_typeScalarFieldEnum[]
  }

  /**
   * course_material without action
   */
  export type course_materialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_material
     */
    select?: course_materialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_material
     */
    omit?: course_materialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_materialInclude<ExtArgs> | null
  }


  /**
   * Model session_type
   */

  export type AggregateSession_type = {
    _count: Session_typeCountAggregateOutputType | null
    _avg: Session_typeAvgAggregateOutputType | null
    _sum: Session_typeSumAggregateOutputType | null
    _min: Session_typeMinAggregateOutputType | null
    _max: Session_typeMaxAggregateOutputType | null
  }

  export type Session_typeAvgAggregateOutputType = {
    nb_repetitions: number | null
  }

  export type Session_typeSumAggregateOutputType = {
    nb_repetitions: number | null
  }

  export type Session_typeMinAggregateOutputType = {
    id: string | null
    course_type_name: string | null
    nb_repetitions: number | null
    full_promo: boolean | null
    course_material_id: string | null
  }

  export type Session_typeMaxAggregateOutputType = {
    id: string | null
    course_type_name: string | null
    nb_repetitions: number | null
    full_promo: boolean | null
    course_material_id: string | null
  }

  export type Session_typeCountAggregateOutputType = {
    id: number
    course_type_name: number
    nb_repetitions: number
    full_promo: number
    course_material_id: number
    _all: number
  }


  export type Session_typeAvgAggregateInputType = {
    nb_repetitions?: true
  }

  export type Session_typeSumAggregateInputType = {
    nb_repetitions?: true
  }

  export type Session_typeMinAggregateInputType = {
    id?: true
    course_type_name?: true
    nb_repetitions?: true
    full_promo?: true
    course_material_id?: true
  }

  export type Session_typeMaxAggregateInputType = {
    id?: true
    course_type_name?: true
    nb_repetitions?: true
    full_promo?: true
    course_material_id?: true
  }

  export type Session_typeCountAggregateInputType = {
    id?: true
    course_type_name?: true
    nb_repetitions?: true
    full_promo?: true
    course_material_id?: true
    _all?: true
  }

  export type Session_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_type to aggregate.
     */
    where?: session_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_types to fetch.
     */
    orderBy?: session_typeOrderByWithRelationInput | session_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: session_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned session_types
    **/
    _count?: true | Session_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Session_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Session_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Session_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Session_typeMaxAggregateInputType
  }

  export type GetSession_typeAggregateType<T extends Session_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateSession_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession_type[P]>
      : GetScalarType<T[P], AggregateSession_type[P]>
  }




  export type session_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_typeWhereInput
    orderBy?: session_typeOrderByWithAggregationInput | session_typeOrderByWithAggregationInput[]
    by: Session_typeScalarFieldEnum[] | Session_typeScalarFieldEnum
    having?: session_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Session_typeCountAggregateInputType | true
    _avg?: Session_typeAvgAggregateInputType
    _sum?: Session_typeSumAggregateInputType
    _min?: Session_typeMinAggregateInputType
    _max?: Session_typeMaxAggregateInputType
  }

  export type Session_typeGroupByOutputType = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
    course_material_id: string
    _count: Session_typeCountAggregateOutputType | null
    _avg: Session_typeAvgAggregateOutputType | null
    _sum: Session_typeSumAggregateOutputType | null
    _min: Session_typeMinAggregateOutputType | null
    _max: Session_typeMaxAggregateOutputType | null
  }

  type GetSession_typeGroupByPayload<T extends session_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Session_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Session_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Session_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Session_typeGroupByOutputType[P]>
        }
      >
    >


  export type session_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_type_name?: boolean
    nb_repetitions?: boolean
    full_promo?: boolean
    course_material_id?: boolean
    session_type_course_material?: boolean | course_materialDefaultArgs<ExtArgs>
    session_type_slot?: boolean | session_type$session_type_slotArgs<ExtArgs>
    _count?: boolean | Session_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_type"]>

  export type session_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_type_name?: boolean
    nb_repetitions?: boolean
    full_promo?: boolean
    course_material_id?: boolean
    session_type_course_material?: boolean | course_materialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_type"]>

  export type session_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_type_name?: boolean
    nb_repetitions?: boolean
    full_promo?: boolean
    course_material_id?: boolean
    session_type_course_material?: boolean | course_materialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_type"]>

  export type session_typeSelectScalar = {
    id?: boolean
    course_type_name?: boolean
    nb_repetitions?: boolean
    full_promo?: boolean
    course_material_id?: boolean
  }

  export type session_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "course_type_name" | "nb_repetitions" | "full_promo" | "course_material_id", ExtArgs["result"]["session_type"]>
  export type session_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session_type_course_material?: boolean | course_materialDefaultArgs<ExtArgs>
    session_type_slot?: boolean | session_type$session_type_slotArgs<ExtArgs>
    _count?: boolean | Session_typeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type session_typeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session_type_course_material?: boolean | course_materialDefaultArgs<ExtArgs>
  }
  export type session_typeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session_type_course_material?: boolean | course_materialDefaultArgs<ExtArgs>
  }

  export type $session_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session_type"
    objects: {
      session_type_course_material: Prisma.$course_materialPayload<ExtArgs>
      session_type_slot: Prisma.$slotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      course_type_name: string
      nb_repetitions: number
      full_promo: boolean
      course_material_id: string
    }, ExtArgs["result"]["session_type"]>
    composites: {}
  }

  type session_typeGetPayload<S extends boolean | null | undefined | session_typeDefaultArgs> = $Result.GetResult<Prisma.$session_typePayload, S>

  type session_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<session_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Session_typeCountAggregateInputType | true
    }

  export interface session_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session_type'], meta: { name: 'session_type' } }
    /**
     * Find zero or one Session_type that matches the filter.
     * @param {session_typeFindUniqueArgs} args - Arguments to find a Session_type
     * @example
     * // Get one Session_type
     * const session_type = await prisma.session_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends session_typeFindUniqueArgs>(args: SelectSubset<T, session_typeFindUniqueArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {session_typeFindUniqueOrThrowArgs} args - Arguments to find a Session_type
     * @example
     * // Get one Session_type
     * const session_type = await prisma.session_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends session_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, session_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_typeFindFirstArgs} args - Arguments to find a Session_type
     * @example
     * // Get one Session_type
     * const session_type = await prisma.session_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends session_typeFindFirstArgs>(args?: SelectSubset<T, session_typeFindFirstArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_typeFindFirstOrThrowArgs} args - Arguments to find a Session_type
     * @example
     * // Get one Session_type
     * const session_type = await prisma.session_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends session_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, session_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Session_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Session_types
     * const session_types = await prisma.session_type.findMany()
     * 
     * // Get first 10 Session_types
     * const session_types = await prisma.session_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const session_typeWithIdOnly = await prisma.session_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends session_typeFindManyArgs>(args?: SelectSubset<T, session_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session_type.
     * @param {session_typeCreateArgs} args - Arguments to create a Session_type.
     * @example
     * // Create one Session_type
     * const Session_type = await prisma.session_type.create({
     *   data: {
     *     // ... data to create a Session_type
     *   }
     * })
     * 
     */
    create<T extends session_typeCreateArgs>(args: SelectSubset<T, session_typeCreateArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Session_types.
     * @param {session_typeCreateManyArgs} args - Arguments to create many Session_types.
     * @example
     * // Create many Session_types
     * const session_type = await prisma.session_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends session_typeCreateManyArgs>(args?: SelectSubset<T, session_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Session_types and returns the data saved in the database.
     * @param {session_typeCreateManyAndReturnArgs} args - Arguments to create many Session_types.
     * @example
     * // Create many Session_types
     * const session_type = await prisma.session_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Session_types and only return the `id`
     * const session_typeWithIdOnly = await prisma.session_type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends session_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, session_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session_type.
     * @param {session_typeDeleteArgs} args - Arguments to delete one Session_type.
     * @example
     * // Delete one Session_type
     * const Session_type = await prisma.session_type.delete({
     *   where: {
     *     // ... filter to delete one Session_type
     *   }
     * })
     * 
     */
    delete<T extends session_typeDeleteArgs>(args: SelectSubset<T, session_typeDeleteArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session_type.
     * @param {session_typeUpdateArgs} args - Arguments to update one Session_type.
     * @example
     * // Update one Session_type
     * const session_type = await prisma.session_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends session_typeUpdateArgs>(args: SelectSubset<T, session_typeUpdateArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Session_types.
     * @param {session_typeDeleteManyArgs} args - Arguments to filter Session_types to delete.
     * @example
     * // Delete a few Session_types
     * const { count } = await prisma.session_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends session_typeDeleteManyArgs>(args?: SelectSubset<T, session_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Session_types
     * const session_type = await prisma.session_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends session_typeUpdateManyArgs>(args: SelectSubset<T, session_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_types and returns the data updated in the database.
     * @param {session_typeUpdateManyAndReturnArgs} args - Arguments to update many Session_types.
     * @example
     * // Update many Session_types
     * const session_type = await prisma.session_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Session_types and only return the `id`
     * const session_typeWithIdOnly = await prisma.session_type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends session_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, session_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session_type.
     * @param {session_typeUpsertArgs} args - Arguments to update or create a Session_type.
     * @example
     * // Update or create a Session_type
     * const session_type = await prisma.session_type.upsert({
     *   create: {
     *     // ... data to create a Session_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session_type we want to update
     *   }
     * })
     */
    upsert<T extends session_typeUpsertArgs>(args: SelectSubset<T, session_typeUpsertArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Session_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_typeCountArgs} args - Arguments to filter Session_types to count.
     * @example
     * // Count the number of Session_types
     * const count = await prisma.session_type.count({
     *   where: {
     *     // ... the filter for the Session_types we want to count
     *   }
     * })
    **/
    count<T extends session_typeCountArgs>(
      args?: Subset<T, session_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Session_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Session_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Session_typeAggregateArgs>(args: Subset<T, Session_typeAggregateArgs>): Prisma.PrismaPromise<GetSession_typeAggregateType<T>>

    /**
     * Group by Session_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends session_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: session_typeGroupByArgs['orderBy'] }
        : { orderBy?: session_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, session_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSession_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session_type model
   */
  readonly fields: session_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__session_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session_type_course_material<T extends course_materialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, course_materialDefaultArgs<ExtArgs>>): Prisma__course_materialClient<$Result.GetResult<Prisma.$course_materialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session_type_slot<T extends session_type$session_type_slotArgs<ExtArgs> = {}>(args?: Subset<T, session_type$session_type_slotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session_type model
   */
  interface session_typeFieldRefs {
    readonly id: FieldRef<"session_type", 'String'>
    readonly course_type_name: FieldRef<"session_type", 'String'>
    readonly nb_repetitions: FieldRef<"session_type", 'Int'>
    readonly full_promo: FieldRef<"session_type", 'Boolean'>
    readonly course_material_id: FieldRef<"session_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * session_type findUnique
   */
  export type session_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * Filter, which session_type to fetch.
     */
    where: session_typeWhereUniqueInput
  }

  /**
   * session_type findUniqueOrThrow
   */
  export type session_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * Filter, which session_type to fetch.
     */
    where: session_typeWhereUniqueInput
  }

  /**
   * session_type findFirst
   */
  export type session_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * Filter, which session_type to fetch.
     */
    where?: session_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_types to fetch.
     */
    orderBy?: session_typeOrderByWithRelationInput | session_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_types.
     */
    cursor?: session_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_types.
     */
    distinct?: Session_typeScalarFieldEnum | Session_typeScalarFieldEnum[]
  }

  /**
   * session_type findFirstOrThrow
   */
  export type session_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * Filter, which session_type to fetch.
     */
    where?: session_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_types to fetch.
     */
    orderBy?: session_typeOrderByWithRelationInput | session_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_types.
     */
    cursor?: session_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_types.
     */
    distinct?: Session_typeScalarFieldEnum | Session_typeScalarFieldEnum[]
  }

  /**
   * session_type findMany
   */
  export type session_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * Filter, which session_types to fetch.
     */
    where?: session_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_types to fetch.
     */
    orderBy?: session_typeOrderByWithRelationInput | session_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing session_types.
     */
    cursor?: session_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_types.
     */
    skip?: number
    distinct?: Session_typeScalarFieldEnum | Session_typeScalarFieldEnum[]
  }

  /**
   * session_type create
   */
  export type session_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a session_type.
     */
    data: XOR<session_typeCreateInput, session_typeUncheckedCreateInput>
  }

  /**
   * session_type createMany
   */
  export type session_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many session_types.
     */
    data: session_typeCreateManyInput | session_typeCreateManyInput[]
  }

  /**
   * session_type createManyAndReturn
   */
  export type session_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * The data used to create many session_types.
     */
    data: session_typeCreateManyInput | session_typeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * session_type update
   */
  export type session_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a session_type.
     */
    data: XOR<session_typeUpdateInput, session_typeUncheckedUpdateInput>
    /**
     * Choose, which session_type to update.
     */
    where: session_typeWhereUniqueInput
  }

  /**
   * session_type updateMany
   */
  export type session_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update session_types.
     */
    data: XOR<session_typeUpdateManyMutationInput, session_typeUncheckedUpdateManyInput>
    /**
     * Filter which session_types to update
     */
    where?: session_typeWhereInput
    /**
     * Limit how many session_types to update.
     */
    limit?: number
  }

  /**
   * session_type updateManyAndReturn
   */
  export type session_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * The data used to update session_types.
     */
    data: XOR<session_typeUpdateManyMutationInput, session_typeUncheckedUpdateManyInput>
    /**
     * Filter which session_types to update
     */
    where?: session_typeWhereInput
    /**
     * Limit how many session_types to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * session_type upsert
   */
  export type session_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the session_type to update in case it exists.
     */
    where: session_typeWhereUniqueInput
    /**
     * In case the session_type found by the `where` argument doesn't exist, create a new session_type with this data.
     */
    create: XOR<session_typeCreateInput, session_typeUncheckedCreateInput>
    /**
     * In case the session_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<session_typeUpdateInput, session_typeUncheckedUpdateInput>
  }

  /**
   * session_type delete
   */
  export type session_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
    /**
     * Filter which session_type to delete.
     */
    where: session_typeWhereUniqueInput
  }

  /**
   * session_type deleteMany
   */
  export type session_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_types to delete
     */
    where?: session_typeWhereInput
    /**
     * Limit how many session_types to delete.
     */
    limit?: number
  }

  /**
   * session_type.session_type_slot
   */
  export type session_type$session_type_slotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    where?: slotWhereInput
    orderBy?: slotOrderByWithRelationInput | slotOrderByWithRelationInput[]
    cursor?: slotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * session_type without action
   */
  export type session_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_type
     */
    select?: session_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_type
     */
    omit?: session_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_typeInclude<ExtArgs> | null
  }


  /**
   * Model presence
   */

  export type AggregatePresence = {
    _count: PresenceCountAggregateOutputType | null
    _min: PresenceMinAggregateOutputType | null
    _max: PresenceMaxAggregateOutputType | null
  }

  export type PresenceMinAggregateOutputType = {
    student_id: string | null
    slot_id: string | null
  }

  export type PresenceMaxAggregateOutputType = {
    student_id: string | null
    slot_id: string | null
  }

  export type PresenceCountAggregateOutputType = {
    student_id: number
    slot_id: number
    _all: number
  }


  export type PresenceMinAggregateInputType = {
    student_id?: true
    slot_id?: true
  }

  export type PresenceMaxAggregateInputType = {
    student_id?: true
    slot_id?: true
  }

  export type PresenceCountAggregateInputType = {
    student_id?: true
    slot_id?: true
    _all?: true
  }

  export type PresenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which presence to aggregate.
     */
    where?: presenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presences to fetch.
     */
    orderBy?: presenceOrderByWithRelationInput | presenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: presenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned presences
    **/
    _count?: true | PresenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresenceMaxAggregateInputType
  }

  export type GetPresenceAggregateType<T extends PresenceAggregateArgs> = {
        [P in keyof T & keyof AggregatePresence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresence[P]>
      : GetScalarType<T[P], AggregatePresence[P]>
  }




  export type presenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: presenceWhereInput
    orderBy?: presenceOrderByWithAggregationInput | presenceOrderByWithAggregationInput[]
    by: PresenceScalarFieldEnum[] | PresenceScalarFieldEnum
    having?: presenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresenceCountAggregateInputType | true
    _min?: PresenceMinAggregateInputType
    _max?: PresenceMaxAggregateInputType
  }

  export type PresenceGroupByOutputType = {
    student_id: string
    slot_id: string
    _count: PresenceCountAggregateOutputType | null
    _min: PresenceMinAggregateOutputType | null
    _max: PresenceMaxAggregateOutputType | null
  }

  type GetPresenceGroupByPayload<T extends presenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresenceGroupByOutputType[P]>
            : GetScalarType<T[P], PresenceGroupByOutputType[P]>
        }
      >
    >


  export type presenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    slot_id?: boolean
    presence_student?: boolean | studentDefaultArgs<ExtArgs>
    presence_slot?: boolean | slotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presence"]>

  export type presenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    slot_id?: boolean
    presence_student?: boolean | studentDefaultArgs<ExtArgs>
    presence_slot?: boolean | slotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presence"]>

  export type presenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    slot_id?: boolean
    presence_student?: boolean | studentDefaultArgs<ExtArgs>
    presence_slot?: boolean | slotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presence"]>

  export type presenceSelectScalar = {
    student_id?: boolean
    slot_id?: boolean
  }

  export type presenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"student_id" | "slot_id", ExtArgs["result"]["presence"]>
  export type presenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presence_student?: boolean | studentDefaultArgs<ExtArgs>
    presence_slot?: boolean | slotDefaultArgs<ExtArgs>
  }
  export type presenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presence_student?: boolean | studentDefaultArgs<ExtArgs>
    presence_slot?: boolean | slotDefaultArgs<ExtArgs>
  }
  export type presenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presence_student?: boolean | studentDefaultArgs<ExtArgs>
    presence_slot?: boolean | slotDefaultArgs<ExtArgs>
  }

  export type $presencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "presence"
    objects: {
      presence_student: Prisma.$studentPayload<ExtArgs>
      presence_slot: Prisma.$slotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      student_id: string
      slot_id: string
    }, ExtArgs["result"]["presence"]>
    composites: {}
  }

  type presenceGetPayload<S extends boolean | null | undefined | presenceDefaultArgs> = $Result.GetResult<Prisma.$presencePayload, S>

  type presenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<presenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresenceCountAggregateInputType | true
    }

  export interface presenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['presence'], meta: { name: 'presence' } }
    /**
     * Find zero or one Presence that matches the filter.
     * @param {presenceFindUniqueArgs} args - Arguments to find a Presence
     * @example
     * // Get one Presence
     * const presence = await prisma.presence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends presenceFindUniqueArgs>(args: SelectSubset<T, presenceFindUniqueArgs<ExtArgs>>): Prisma__presenceClient<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Presence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {presenceFindUniqueOrThrowArgs} args - Arguments to find a Presence
     * @example
     * // Get one Presence
     * const presence = await prisma.presence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends presenceFindUniqueOrThrowArgs>(args: SelectSubset<T, presenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__presenceClient<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Presence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presenceFindFirstArgs} args - Arguments to find a Presence
     * @example
     * // Get one Presence
     * const presence = await prisma.presence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends presenceFindFirstArgs>(args?: SelectSubset<T, presenceFindFirstArgs<ExtArgs>>): Prisma__presenceClient<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Presence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presenceFindFirstOrThrowArgs} args - Arguments to find a Presence
     * @example
     * // Get one Presence
     * const presence = await prisma.presence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends presenceFindFirstOrThrowArgs>(args?: SelectSubset<T, presenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__presenceClient<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Presences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presences
     * const presences = await prisma.presence.findMany()
     * 
     * // Get first 10 Presences
     * const presences = await prisma.presence.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const presenceWithStudent_idOnly = await prisma.presence.findMany({ select: { student_id: true } })
     * 
     */
    findMany<T extends presenceFindManyArgs>(args?: SelectSubset<T, presenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Presence.
     * @param {presenceCreateArgs} args - Arguments to create a Presence.
     * @example
     * // Create one Presence
     * const Presence = await prisma.presence.create({
     *   data: {
     *     // ... data to create a Presence
     *   }
     * })
     * 
     */
    create<T extends presenceCreateArgs>(args: SelectSubset<T, presenceCreateArgs<ExtArgs>>): Prisma__presenceClient<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Presences.
     * @param {presenceCreateManyArgs} args - Arguments to create many Presences.
     * @example
     * // Create many Presences
     * const presence = await prisma.presence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends presenceCreateManyArgs>(args?: SelectSubset<T, presenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Presences and returns the data saved in the database.
     * @param {presenceCreateManyAndReturnArgs} args - Arguments to create many Presences.
     * @example
     * // Create many Presences
     * const presence = await prisma.presence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Presences and only return the `student_id`
     * const presenceWithStudent_idOnly = await prisma.presence.createManyAndReturn({
     *   select: { student_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends presenceCreateManyAndReturnArgs>(args?: SelectSubset<T, presenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Presence.
     * @param {presenceDeleteArgs} args - Arguments to delete one Presence.
     * @example
     * // Delete one Presence
     * const Presence = await prisma.presence.delete({
     *   where: {
     *     // ... filter to delete one Presence
     *   }
     * })
     * 
     */
    delete<T extends presenceDeleteArgs>(args: SelectSubset<T, presenceDeleteArgs<ExtArgs>>): Prisma__presenceClient<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Presence.
     * @param {presenceUpdateArgs} args - Arguments to update one Presence.
     * @example
     * // Update one Presence
     * const presence = await prisma.presence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends presenceUpdateArgs>(args: SelectSubset<T, presenceUpdateArgs<ExtArgs>>): Prisma__presenceClient<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Presences.
     * @param {presenceDeleteManyArgs} args - Arguments to filter Presences to delete.
     * @example
     * // Delete a few Presences
     * const { count } = await prisma.presence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends presenceDeleteManyArgs>(args?: SelectSubset<T, presenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presences
     * const presence = await prisma.presence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends presenceUpdateManyArgs>(args: SelectSubset<T, presenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presences and returns the data updated in the database.
     * @param {presenceUpdateManyAndReturnArgs} args - Arguments to update many Presences.
     * @example
     * // Update many Presences
     * const presence = await prisma.presence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Presences and only return the `student_id`
     * const presenceWithStudent_idOnly = await prisma.presence.updateManyAndReturn({
     *   select: { student_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends presenceUpdateManyAndReturnArgs>(args: SelectSubset<T, presenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Presence.
     * @param {presenceUpsertArgs} args - Arguments to update or create a Presence.
     * @example
     * // Update or create a Presence
     * const presence = await prisma.presence.upsert({
     *   create: {
     *     // ... data to create a Presence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Presence we want to update
     *   }
     * })
     */
    upsert<T extends presenceUpsertArgs>(args: SelectSubset<T, presenceUpsertArgs<ExtArgs>>): Prisma__presenceClient<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Presences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presenceCountArgs} args - Arguments to filter Presences to count.
     * @example
     * // Count the number of Presences
     * const count = await prisma.presence.count({
     *   where: {
     *     // ... the filter for the Presences we want to count
     *   }
     * })
    **/
    count<T extends presenceCountArgs>(
      args?: Subset<T, presenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Presence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresenceAggregateArgs>(args: Subset<T, PresenceAggregateArgs>): Prisma.PrismaPromise<GetPresenceAggregateType<T>>

    /**
     * Group by Presence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {presenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends presenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: presenceGroupByArgs['orderBy'] }
        : { orderBy?: presenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, presenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the presence model
   */
  readonly fields: presenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for presence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__presenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    presence_student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    presence_slot<T extends slotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, slotDefaultArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the presence model
   */
  interface presenceFieldRefs {
    readonly student_id: FieldRef<"presence", 'String'>
    readonly slot_id: FieldRef<"presence", 'String'>
  }
    

  // Custom InputTypes
  /**
   * presence findUnique
   */
  export type presenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * Filter, which presence to fetch.
     */
    where: presenceWhereUniqueInput
  }

  /**
   * presence findUniqueOrThrow
   */
  export type presenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * Filter, which presence to fetch.
     */
    where: presenceWhereUniqueInput
  }

  /**
   * presence findFirst
   */
  export type presenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * Filter, which presence to fetch.
     */
    where?: presenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presences to fetch.
     */
    orderBy?: presenceOrderByWithRelationInput | presenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presences.
     */
    cursor?: presenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presences.
     */
    distinct?: PresenceScalarFieldEnum | PresenceScalarFieldEnum[]
  }

  /**
   * presence findFirstOrThrow
   */
  export type presenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * Filter, which presence to fetch.
     */
    where?: presenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presences to fetch.
     */
    orderBy?: presenceOrderByWithRelationInput | presenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for presences.
     */
    cursor?: presenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of presences.
     */
    distinct?: PresenceScalarFieldEnum | PresenceScalarFieldEnum[]
  }

  /**
   * presence findMany
   */
  export type presenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * Filter, which presences to fetch.
     */
    where?: presenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of presences to fetch.
     */
    orderBy?: presenceOrderByWithRelationInput | presenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing presences.
     */
    cursor?: presenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` presences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` presences.
     */
    skip?: number
    distinct?: PresenceScalarFieldEnum | PresenceScalarFieldEnum[]
  }

  /**
   * presence create
   */
  export type presenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * The data needed to create a presence.
     */
    data: XOR<presenceCreateInput, presenceUncheckedCreateInput>
  }

  /**
   * presence createMany
   */
  export type presenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many presences.
     */
    data: presenceCreateManyInput | presenceCreateManyInput[]
  }

  /**
   * presence createManyAndReturn
   */
  export type presenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * The data used to create many presences.
     */
    data: presenceCreateManyInput | presenceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * presence update
   */
  export type presenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * The data needed to update a presence.
     */
    data: XOR<presenceUpdateInput, presenceUncheckedUpdateInput>
    /**
     * Choose, which presence to update.
     */
    where: presenceWhereUniqueInput
  }

  /**
   * presence updateMany
   */
  export type presenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update presences.
     */
    data: XOR<presenceUpdateManyMutationInput, presenceUncheckedUpdateManyInput>
    /**
     * Filter which presences to update
     */
    where?: presenceWhereInput
    /**
     * Limit how many presences to update.
     */
    limit?: number
  }

  /**
   * presence updateManyAndReturn
   */
  export type presenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * The data used to update presences.
     */
    data: XOR<presenceUpdateManyMutationInput, presenceUncheckedUpdateManyInput>
    /**
     * Filter which presences to update
     */
    where?: presenceWhereInput
    /**
     * Limit how many presences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * presence upsert
   */
  export type presenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * The filter to search for the presence to update in case it exists.
     */
    where: presenceWhereUniqueInput
    /**
     * In case the presence found by the `where` argument doesn't exist, create a new presence with this data.
     */
    create: XOR<presenceCreateInput, presenceUncheckedCreateInput>
    /**
     * In case the presence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<presenceUpdateInput, presenceUncheckedUpdateInput>
  }

  /**
   * presence delete
   */
  export type presenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    /**
     * Filter which presence to delete.
     */
    where: presenceWhereUniqueInput
  }

  /**
   * presence deleteMany
   */
  export type presenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which presences to delete
     */
    where?: presenceWhereInput
    /**
     * Limit how many presences to delete.
     */
    limit?: number
  }

  /**
   * presence without action
   */
  export type presenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
  }


  /**
   * Model slot
   */

  export type AggregateSlot = {
    _count: SlotCountAggregateOutputType | null
    _avg: SlotAvgAggregateOutputType | null
    _sum: SlotSumAggregateOutputType | null
    _min: SlotMinAggregateOutputType | null
    _max: SlotMaxAggregateOutputType | null
  }

  export type SlotAvgAggregateOutputType = {
    num_session: number | null
  }

  export type SlotSumAggregateOutputType = {
    num_session: number | null
  }

  export type SlotMinAggregateOutputType = {
    id: string | null
    starting_time: Date | null
    date: Date | null
    num_session: number | null
    group_id: string | null
    supervisor_id: string | null
    session_type_id: string | null
  }

  export type SlotMaxAggregateOutputType = {
    id: string | null
    starting_time: Date | null
    date: Date | null
    num_session: number | null
    group_id: string | null
    supervisor_id: string | null
    session_type_id: string | null
  }

  export type SlotCountAggregateOutputType = {
    id: number
    starting_time: number
    date: number
    num_session: number
    group_id: number
    supervisor_id: number
    session_type_id: number
    _all: number
  }


  export type SlotAvgAggregateInputType = {
    num_session?: true
  }

  export type SlotSumAggregateInputType = {
    num_session?: true
  }

  export type SlotMinAggregateInputType = {
    id?: true
    starting_time?: true
    date?: true
    num_session?: true
    group_id?: true
    supervisor_id?: true
    session_type_id?: true
  }

  export type SlotMaxAggregateInputType = {
    id?: true
    starting_time?: true
    date?: true
    num_session?: true
    group_id?: true
    supervisor_id?: true
    session_type_id?: true
  }

  export type SlotCountAggregateInputType = {
    id?: true
    starting_time?: true
    date?: true
    num_session?: true
    group_id?: true
    supervisor_id?: true
    session_type_id?: true
    _all?: true
  }

  export type SlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which slot to aggregate.
     */
    where?: slotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slots to fetch.
     */
    orderBy?: slotOrderByWithRelationInput | slotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: slotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned slots
    **/
    _count?: true | SlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlotMaxAggregateInputType
  }

  export type GetSlotAggregateType<T extends SlotAggregateArgs> = {
        [P in keyof T & keyof AggregateSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlot[P]>
      : GetScalarType<T[P], AggregateSlot[P]>
  }




  export type slotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: slotWhereInput
    orderBy?: slotOrderByWithAggregationInput | slotOrderByWithAggregationInput[]
    by: SlotScalarFieldEnum[] | SlotScalarFieldEnum
    having?: slotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlotCountAggregateInputType | true
    _avg?: SlotAvgAggregateInputType
    _sum?: SlotSumAggregateInputType
    _min?: SlotMinAggregateInputType
    _max?: SlotMaxAggregateInputType
  }

  export type SlotGroupByOutputType = {
    id: string
    starting_time: Date
    date: Date
    num_session: number
    group_id: string
    supervisor_id: string
    session_type_id: string
    _count: SlotCountAggregateOutputType | null
    _avg: SlotAvgAggregateOutputType | null
    _sum: SlotSumAggregateOutputType | null
    _min: SlotMinAggregateOutputType | null
    _max: SlotMaxAggregateOutputType | null
  }

  type GetSlotGroupByPayload<T extends slotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlotGroupByOutputType[P]>
            : GetScalarType<T[P], SlotGroupByOutputType[P]>
        }
      >
    >


  export type slotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    starting_time?: boolean
    date?: boolean
    num_session?: boolean
    group_id?: boolean
    supervisor_id?: boolean
    session_type_id?: boolean
    slot_presence?: boolean | slot$slot_presenceArgs<ExtArgs>
    slot_group?: boolean | groupDefaultArgs<ExtArgs>
    slot_supervisor?: boolean | supervisorDefaultArgs<ExtArgs>
    slot_seesion_type?: boolean | session_typeDefaultArgs<ExtArgs>
    _count?: boolean | SlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type slotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    starting_time?: boolean
    date?: boolean
    num_session?: boolean
    group_id?: boolean
    supervisor_id?: boolean
    session_type_id?: boolean
    slot_group?: boolean | groupDefaultArgs<ExtArgs>
    slot_supervisor?: boolean | supervisorDefaultArgs<ExtArgs>
    slot_seesion_type?: boolean | session_typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type slotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    starting_time?: boolean
    date?: boolean
    num_session?: boolean
    group_id?: boolean
    supervisor_id?: boolean
    session_type_id?: boolean
    slot_group?: boolean | groupDefaultArgs<ExtArgs>
    slot_supervisor?: boolean | supervisorDefaultArgs<ExtArgs>
    slot_seesion_type?: boolean | session_typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type slotSelectScalar = {
    id?: boolean
    starting_time?: boolean
    date?: boolean
    num_session?: boolean
    group_id?: boolean
    supervisor_id?: boolean
    session_type_id?: boolean
  }

  export type slotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "starting_time" | "date" | "num_session" | "group_id" | "supervisor_id" | "session_type_id", ExtArgs["result"]["slot"]>
  export type slotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slot_presence?: boolean | slot$slot_presenceArgs<ExtArgs>
    slot_group?: boolean | groupDefaultArgs<ExtArgs>
    slot_supervisor?: boolean | supervisorDefaultArgs<ExtArgs>
    slot_seesion_type?: boolean | session_typeDefaultArgs<ExtArgs>
    _count?: boolean | SlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type slotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slot_group?: boolean | groupDefaultArgs<ExtArgs>
    slot_supervisor?: boolean | supervisorDefaultArgs<ExtArgs>
    slot_seesion_type?: boolean | session_typeDefaultArgs<ExtArgs>
  }
  export type slotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slot_group?: boolean | groupDefaultArgs<ExtArgs>
    slot_supervisor?: boolean | supervisorDefaultArgs<ExtArgs>
    slot_seesion_type?: boolean | session_typeDefaultArgs<ExtArgs>
  }

  export type $slotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "slot"
    objects: {
      slot_presence: Prisma.$presencePayload<ExtArgs>[]
      slot_group: Prisma.$groupPayload<ExtArgs>
      slot_supervisor: Prisma.$supervisorPayload<ExtArgs>
      slot_seesion_type: Prisma.$session_typePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      starting_time: Date
      date: Date
      num_session: number
      group_id: string
      supervisor_id: string
      session_type_id: string
    }, ExtArgs["result"]["slot"]>
    composites: {}
  }

  type slotGetPayload<S extends boolean | null | undefined | slotDefaultArgs> = $Result.GetResult<Prisma.$slotPayload, S>

  type slotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<slotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SlotCountAggregateInputType | true
    }

  export interface slotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['slot'], meta: { name: 'slot' } }
    /**
     * Find zero or one Slot that matches the filter.
     * @param {slotFindUniqueArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends slotFindUniqueArgs>(args: SelectSubset<T, slotFindUniqueArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Slot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {slotFindUniqueOrThrowArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends slotFindUniqueOrThrowArgs>(args: SelectSubset<T, slotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Slot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slotFindFirstArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends slotFindFirstArgs>(args?: SelectSubset<T, slotFindFirstArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Slot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slotFindFirstOrThrowArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends slotFindFirstOrThrowArgs>(args?: SelectSubset<T, slotFindFirstOrThrowArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slots
     * const slots = await prisma.slot.findMany()
     * 
     * // Get first 10 Slots
     * const slots = await prisma.slot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slotWithIdOnly = await prisma.slot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends slotFindManyArgs>(args?: SelectSubset<T, slotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Slot.
     * @param {slotCreateArgs} args - Arguments to create a Slot.
     * @example
     * // Create one Slot
     * const Slot = await prisma.slot.create({
     *   data: {
     *     // ... data to create a Slot
     *   }
     * })
     * 
     */
    create<T extends slotCreateArgs>(args: SelectSubset<T, slotCreateArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Slots.
     * @param {slotCreateManyArgs} args - Arguments to create many Slots.
     * @example
     * // Create many Slots
     * const slot = await prisma.slot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends slotCreateManyArgs>(args?: SelectSubset<T, slotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Slots and returns the data saved in the database.
     * @param {slotCreateManyAndReturnArgs} args - Arguments to create many Slots.
     * @example
     * // Create many Slots
     * const slot = await prisma.slot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Slots and only return the `id`
     * const slotWithIdOnly = await prisma.slot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends slotCreateManyAndReturnArgs>(args?: SelectSubset<T, slotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Slot.
     * @param {slotDeleteArgs} args - Arguments to delete one Slot.
     * @example
     * // Delete one Slot
     * const Slot = await prisma.slot.delete({
     *   where: {
     *     // ... filter to delete one Slot
     *   }
     * })
     * 
     */
    delete<T extends slotDeleteArgs>(args: SelectSubset<T, slotDeleteArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Slot.
     * @param {slotUpdateArgs} args - Arguments to update one Slot.
     * @example
     * // Update one Slot
     * const slot = await prisma.slot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends slotUpdateArgs>(args: SelectSubset<T, slotUpdateArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Slots.
     * @param {slotDeleteManyArgs} args - Arguments to filter Slots to delete.
     * @example
     * // Delete a few Slots
     * const { count } = await prisma.slot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends slotDeleteManyArgs>(args?: SelectSubset<T, slotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slots
     * const slot = await prisma.slot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends slotUpdateManyArgs>(args: SelectSubset<T, slotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slots and returns the data updated in the database.
     * @param {slotUpdateManyAndReturnArgs} args - Arguments to update many Slots.
     * @example
     * // Update many Slots
     * const slot = await prisma.slot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Slots and only return the `id`
     * const slotWithIdOnly = await prisma.slot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends slotUpdateManyAndReturnArgs>(args: SelectSubset<T, slotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Slot.
     * @param {slotUpsertArgs} args - Arguments to update or create a Slot.
     * @example
     * // Update or create a Slot
     * const slot = await prisma.slot.upsert({
     *   create: {
     *     // ... data to create a Slot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slot we want to update
     *   }
     * })
     */
    upsert<T extends slotUpsertArgs>(args: SelectSubset<T, slotUpsertArgs<ExtArgs>>): Prisma__slotClient<$Result.GetResult<Prisma.$slotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slotCountArgs} args - Arguments to filter Slots to count.
     * @example
     * // Count the number of Slots
     * const count = await prisma.slot.count({
     *   where: {
     *     // ... the filter for the Slots we want to count
     *   }
     * })
    **/
    count<T extends slotCountArgs>(
      args?: Subset<T, slotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlotAggregateArgs>(args: Subset<T, SlotAggregateArgs>): Prisma.PrismaPromise<GetSlotAggregateType<T>>

    /**
     * Group by Slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends slotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: slotGroupByArgs['orderBy'] }
        : { orderBy?: slotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, slotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the slot model
   */
  readonly fields: slotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for slot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__slotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    slot_presence<T extends slot$slot_presenceArgs<ExtArgs> = {}>(args?: Subset<T, slot$slot_presenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$presencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slot_group<T extends groupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupDefaultArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slot_supervisor<T extends supervisorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, supervisorDefaultArgs<ExtArgs>>): Prisma__supervisorClient<$Result.GetResult<Prisma.$supervisorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slot_seesion_type<T extends session_typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, session_typeDefaultArgs<ExtArgs>>): Prisma__session_typeClient<$Result.GetResult<Prisma.$session_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the slot model
   */
  interface slotFieldRefs {
    readonly id: FieldRef<"slot", 'String'>
    readonly starting_time: FieldRef<"slot", 'DateTime'>
    readonly date: FieldRef<"slot", 'DateTime'>
    readonly num_session: FieldRef<"slot", 'Int'>
    readonly group_id: FieldRef<"slot", 'String'>
    readonly supervisor_id: FieldRef<"slot", 'String'>
    readonly session_type_id: FieldRef<"slot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * slot findUnique
   */
  export type slotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * Filter, which slot to fetch.
     */
    where: slotWhereUniqueInput
  }

  /**
   * slot findUniqueOrThrow
   */
  export type slotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * Filter, which slot to fetch.
     */
    where: slotWhereUniqueInput
  }

  /**
   * slot findFirst
   */
  export type slotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * Filter, which slot to fetch.
     */
    where?: slotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slots to fetch.
     */
    orderBy?: slotOrderByWithRelationInput | slotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slots.
     */
    cursor?: slotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slots.
     */
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * slot findFirstOrThrow
   */
  export type slotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * Filter, which slot to fetch.
     */
    where?: slotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slots to fetch.
     */
    orderBy?: slotOrderByWithRelationInput | slotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slots.
     */
    cursor?: slotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slots.
     */
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * slot findMany
   */
  export type slotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * Filter, which slots to fetch.
     */
    where?: slotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slots to fetch.
     */
    orderBy?: slotOrderByWithRelationInput | slotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing slots.
     */
    cursor?: slotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slots.
     */
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * slot create
   */
  export type slotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * The data needed to create a slot.
     */
    data: XOR<slotCreateInput, slotUncheckedCreateInput>
  }

  /**
   * slot createMany
   */
  export type slotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many slots.
     */
    data: slotCreateManyInput | slotCreateManyInput[]
  }

  /**
   * slot createManyAndReturn
   */
  export type slotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * The data used to create many slots.
     */
    data: slotCreateManyInput | slotCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * slot update
   */
  export type slotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * The data needed to update a slot.
     */
    data: XOR<slotUpdateInput, slotUncheckedUpdateInput>
    /**
     * Choose, which slot to update.
     */
    where: slotWhereUniqueInput
  }

  /**
   * slot updateMany
   */
  export type slotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update slots.
     */
    data: XOR<slotUpdateManyMutationInput, slotUncheckedUpdateManyInput>
    /**
     * Filter which slots to update
     */
    where?: slotWhereInput
    /**
     * Limit how many slots to update.
     */
    limit?: number
  }

  /**
   * slot updateManyAndReturn
   */
  export type slotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * The data used to update slots.
     */
    data: XOR<slotUpdateManyMutationInput, slotUncheckedUpdateManyInput>
    /**
     * Filter which slots to update
     */
    where?: slotWhereInput
    /**
     * Limit how many slots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * slot upsert
   */
  export type slotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * The filter to search for the slot to update in case it exists.
     */
    where: slotWhereUniqueInput
    /**
     * In case the slot found by the `where` argument doesn't exist, create a new slot with this data.
     */
    create: XOR<slotCreateInput, slotUncheckedCreateInput>
    /**
     * In case the slot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<slotUpdateInput, slotUncheckedUpdateInput>
  }

  /**
   * slot delete
   */
  export type slotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
    /**
     * Filter which slot to delete.
     */
    where: slotWhereUniqueInput
  }

  /**
   * slot deleteMany
   */
  export type slotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which slots to delete
     */
    where?: slotWhereInput
    /**
     * Limit how many slots to delete.
     */
    limit?: number
  }

  /**
   * slot.slot_presence
   */
  export type slot$slot_presenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the presence
     */
    select?: presenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the presence
     */
    omit?: presenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: presenceInclude<ExtArgs> | null
    where?: presenceWhereInput
    orderBy?: presenceOrderByWithRelationInput | presenceOrderByWithRelationInput[]
    cursor?: presenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresenceScalarFieldEnum | PresenceScalarFieldEnum[]
  }

  /**
   * slot without action
   */
  export type slotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot
     */
    select?: slotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot
     */
    omit?: slotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: slotInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SupervisorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    mail: 'mail'
  };

  export type SupervisorScalarFieldEnum = (typeof SupervisorScalarFieldEnum)[keyof typeof SupervisorScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    first_name: 'first_name',
    mail: 'mail'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const InscriptionScalarFieldEnum: {
    student_id: 'student_id',
    group_id: 'group_id'
  };

  export type InscriptionScalarFieldEnum = (typeof InscriptionScalarFieldEnum)[keyof typeof InscriptionScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    semester_id: 'semester_id'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const SemesterScalarFieldEnum: {
    id: 'id',
    year: 'year',
    name: 'name'
  };

  export type SemesterScalarFieldEnum = (typeof SemesterScalarFieldEnum)[keyof typeof SemesterScalarFieldEnum]


  export const Course_materialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    semester_id: 'semester_id'
  };

  export type Course_materialScalarFieldEnum = (typeof Course_materialScalarFieldEnum)[keyof typeof Course_materialScalarFieldEnum]


  export const Session_typeScalarFieldEnum: {
    id: 'id',
    course_type_name: 'course_type_name',
    nb_repetitions: 'nb_repetitions',
    full_promo: 'full_promo',
    course_material_id: 'course_material_id'
  };

  export type Session_typeScalarFieldEnum = (typeof Session_typeScalarFieldEnum)[keyof typeof Session_typeScalarFieldEnum]


  export const PresenceScalarFieldEnum: {
    student_id: 'student_id',
    slot_id: 'slot_id'
  };

  export type PresenceScalarFieldEnum = (typeof PresenceScalarFieldEnum)[keyof typeof PresenceScalarFieldEnum]


  export const SlotScalarFieldEnum: {
    id: 'id',
    starting_time: 'starting_time',
    date: 'date',
    num_session: 'num_session',
    group_id: 'group_id',
    supervisor_id: 'supervisor_id',
    session_type_id: 'session_type_id'
  };

  export type SlotScalarFieldEnum = (typeof SlotScalarFieldEnum)[keyof typeof SlotScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type supervisorWhereInput = {
    AND?: supervisorWhereInput | supervisorWhereInput[]
    OR?: supervisorWhereInput[]
    NOT?: supervisorWhereInput | supervisorWhereInput[]
    id?: StringFilter<"supervisor"> | string
    name?: StringFilter<"supervisor"> | string
    mail?: StringFilter<"supervisor"> | string
    supervisor_slot?: SlotListRelationFilter
  }

  export type supervisorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    mail?: SortOrder
    supervisor_slot?: slotOrderByRelationAggregateInput
  }

  export type supervisorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: supervisorWhereInput | supervisorWhereInput[]
    OR?: supervisorWhereInput[]
    NOT?: supervisorWhereInput | supervisorWhereInput[]
    name?: StringFilter<"supervisor"> | string
    mail?: StringFilter<"supervisor"> | string
    supervisor_slot?: SlotListRelationFilter
  }, "id">

  export type supervisorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    mail?: SortOrder
    _count?: supervisorCountOrderByAggregateInput
    _max?: supervisorMaxOrderByAggregateInput
    _min?: supervisorMinOrderByAggregateInput
  }

  export type supervisorScalarWhereWithAggregatesInput = {
    AND?: supervisorScalarWhereWithAggregatesInput | supervisorScalarWhereWithAggregatesInput[]
    OR?: supervisorScalarWhereWithAggregatesInput[]
    NOT?: supervisorScalarWhereWithAggregatesInput | supervisorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"supervisor"> | string
    name?: StringWithAggregatesFilter<"supervisor"> | string
    mail?: StringWithAggregatesFilter<"supervisor"> | string
  }

  export type studentWhereInput = {
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    id?: StringFilter<"student"> | string
    name?: StringFilter<"student"> | string
    first_name?: StringFilter<"student"> | string
    mail?: StringFilter<"student"> | string
    student_inscription?: InscriptionListRelationFilter
    student_presence?: PresenceListRelationFilter
  }

  export type studentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    mail?: SortOrder
    student_inscription?: inscriptionOrderByRelationAggregateInput
    student_presence?: presenceOrderByRelationAggregateInput
  }

  export type studentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    name?: StringFilter<"student"> | string
    first_name?: StringFilter<"student"> | string
    mail?: StringFilter<"student"> | string
    student_inscription?: InscriptionListRelationFilter
    student_presence?: PresenceListRelationFilter
  }, "id">

  export type studentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    mail?: SortOrder
    _count?: studentCountOrderByAggregateInput
    _max?: studentMaxOrderByAggregateInput
    _min?: studentMinOrderByAggregateInput
  }

  export type studentScalarWhereWithAggregatesInput = {
    AND?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    OR?: studentScalarWhereWithAggregatesInput[]
    NOT?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"student"> | string
    name?: StringWithAggregatesFilter<"student"> | string
    first_name?: StringWithAggregatesFilter<"student"> | string
    mail?: StringWithAggregatesFilter<"student"> | string
  }

  export type inscriptionWhereInput = {
    AND?: inscriptionWhereInput | inscriptionWhereInput[]
    OR?: inscriptionWhereInput[]
    NOT?: inscriptionWhereInput | inscriptionWhereInput[]
    student_id?: StringFilter<"inscription"> | string
    group_id?: StringFilter<"inscription"> | string
    inscription_student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    inscription_group?: XOR<GroupScalarRelationFilter, groupWhereInput>
  }

  export type inscriptionOrderByWithRelationInput = {
    student_id?: SortOrder
    group_id?: SortOrder
    inscription_student?: studentOrderByWithRelationInput
    inscription_group?: groupOrderByWithRelationInput
  }

  export type inscriptionWhereUniqueInput = Prisma.AtLeast<{
    student_id_group_id?: inscriptionStudent_idGroup_idCompoundUniqueInput
    AND?: inscriptionWhereInput | inscriptionWhereInput[]
    OR?: inscriptionWhereInput[]
    NOT?: inscriptionWhereInput | inscriptionWhereInput[]
    student_id?: StringFilter<"inscription"> | string
    group_id?: StringFilter<"inscription"> | string
    inscription_student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    inscription_group?: XOR<GroupScalarRelationFilter, groupWhereInput>
  }, "student_id_group_id">

  export type inscriptionOrderByWithAggregationInput = {
    student_id?: SortOrder
    group_id?: SortOrder
    _count?: inscriptionCountOrderByAggregateInput
    _max?: inscriptionMaxOrderByAggregateInput
    _min?: inscriptionMinOrderByAggregateInput
  }

  export type inscriptionScalarWhereWithAggregatesInput = {
    AND?: inscriptionScalarWhereWithAggregatesInput | inscriptionScalarWhereWithAggregatesInput[]
    OR?: inscriptionScalarWhereWithAggregatesInput[]
    NOT?: inscriptionScalarWhereWithAggregatesInput | inscriptionScalarWhereWithAggregatesInput[]
    student_id?: StringWithAggregatesFilter<"inscription"> | string
    group_id?: StringWithAggregatesFilter<"inscription"> | string
  }

  export type groupWhereInput = {
    AND?: groupWhereInput | groupWhereInput[]
    OR?: groupWhereInput[]
    NOT?: groupWhereInput | groupWhereInput[]
    id?: StringFilter<"group"> | string
    name?: StringFilter<"group"> | string
    semester_id?: StringFilter<"group"> | string
    group_semester?: XOR<SemesterScalarRelationFilter, semesterWhereInput>
    group_inscription?: InscriptionListRelationFilter
    group_slot?: SlotListRelationFilter
  }

  export type groupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
    group_semester?: semesterOrderByWithRelationInput
    group_inscription?: inscriptionOrderByRelationAggregateInput
    group_slot?: slotOrderByRelationAggregateInput
  }

  export type groupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: groupWhereInput | groupWhereInput[]
    OR?: groupWhereInput[]
    NOT?: groupWhereInput | groupWhereInput[]
    name?: StringFilter<"group"> | string
    semester_id?: StringFilter<"group"> | string
    group_semester?: XOR<SemesterScalarRelationFilter, semesterWhereInput>
    group_inscription?: InscriptionListRelationFilter
    group_slot?: SlotListRelationFilter
  }, "id">

  export type groupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
    _count?: groupCountOrderByAggregateInput
    _max?: groupMaxOrderByAggregateInput
    _min?: groupMinOrderByAggregateInput
  }

  export type groupScalarWhereWithAggregatesInput = {
    AND?: groupScalarWhereWithAggregatesInput | groupScalarWhereWithAggregatesInput[]
    OR?: groupScalarWhereWithAggregatesInput[]
    NOT?: groupScalarWhereWithAggregatesInput | groupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"group"> | string
    name?: StringWithAggregatesFilter<"group"> | string
    semester_id?: StringWithAggregatesFilter<"group"> | string
  }

  export type semesterWhereInput = {
    AND?: semesterWhereInput | semesterWhereInput[]
    OR?: semesterWhereInput[]
    NOT?: semesterWhereInput | semesterWhereInput[]
    id?: StringFilter<"semester"> | string
    year?: DateTimeFilter<"semester"> | Date | string
    name?: StringFilter<"semester"> | string
    semester_group?: GroupListRelationFilter
    semester_course_material?: Course_materialListRelationFilter
  }

  export type semesterOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    name?: SortOrder
    semester_group?: groupOrderByRelationAggregateInput
    semester_course_material?: course_materialOrderByRelationAggregateInput
  }

  export type semesterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: semesterWhereInput | semesterWhereInput[]
    OR?: semesterWhereInput[]
    NOT?: semesterWhereInput | semesterWhereInput[]
    year?: DateTimeFilter<"semester"> | Date | string
    name?: StringFilter<"semester"> | string
    semester_group?: GroupListRelationFilter
    semester_course_material?: Course_materialListRelationFilter
  }, "id">

  export type semesterOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    name?: SortOrder
    _count?: semesterCountOrderByAggregateInput
    _max?: semesterMaxOrderByAggregateInput
    _min?: semesterMinOrderByAggregateInput
  }

  export type semesterScalarWhereWithAggregatesInput = {
    AND?: semesterScalarWhereWithAggregatesInput | semesterScalarWhereWithAggregatesInput[]
    OR?: semesterScalarWhereWithAggregatesInput[]
    NOT?: semesterScalarWhereWithAggregatesInput | semesterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"semester"> | string
    year?: DateTimeWithAggregatesFilter<"semester"> | Date | string
    name?: StringWithAggregatesFilter<"semester"> | string
  }

  export type course_materialWhereInput = {
    AND?: course_materialWhereInput | course_materialWhereInput[]
    OR?: course_materialWhereInput[]
    NOT?: course_materialWhereInput | course_materialWhereInput[]
    id?: StringFilter<"course_material"> | string
    name?: StringFilter<"course_material"> | string
    semester_id?: StringFilter<"course_material"> | string
    course_material_semester?: XOR<SemesterScalarRelationFilter, semesterWhereInput>
    course_material_session_type?: Session_typeListRelationFilter
  }

  export type course_materialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
    course_material_semester?: semesterOrderByWithRelationInput
    course_material_session_type?: session_typeOrderByRelationAggregateInput
  }

  export type course_materialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: course_materialWhereInput | course_materialWhereInput[]
    OR?: course_materialWhereInput[]
    NOT?: course_materialWhereInput | course_materialWhereInput[]
    name?: StringFilter<"course_material"> | string
    semester_id?: StringFilter<"course_material"> | string
    course_material_semester?: XOR<SemesterScalarRelationFilter, semesterWhereInput>
    course_material_session_type?: Session_typeListRelationFilter
  }, "id">

  export type course_materialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
    _count?: course_materialCountOrderByAggregateInput
    _max?: course_materialMaxOrderByAggregateInput
    _min?: course_materialMinOrderByAggregateInput
  }

  export type course_materialScalarWhereWithAggregatesInput = {
    AND?: course_materialScalarWhereWithAggregatesInput | course_materialScalarWhereWithAggregatesInput[]
    OR?: course_materialScalarWhereWithAggregatesInput[]
    NOT?: course_materialScalarWhereWithAggregatesInput | course_materialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"course_material"> | string
    name?: StringWithAggregatesFilter<"course_material"> | string
    semester_id?: StringWithAggregatesFilter<"course_material"> | string
  }

  export type session_typeWhereInput = {
    AND?: session_typeWhereInput | session_typeWhereInput[]
    OR?: session_typeWhereInput[]
    NOT?: session_typeWhereInput | session_typeWhereInput[]
    id?: StringFilter<"session_type"> | string
    course_type_name?: StringFilter<"session_type"> | string
    nb_repetitions?: IntFilter<"session_type"> | number
    full_promo?: BoolFilter<"session_type"> | boolean
    course_material_id?: StringFilter<"session_type"> | string
    session_type_course_material?: XOR<Course_materialScalarRelationFilter, course_materialWhereInput>
    session_type_slot?: SlotListRelationFilter
  }

  export type session_typeOrderByWithRelationInput = {
    id?: SortOrder
    course_type_name?: SortOrder
    nb_repetitions?: SortOrder
    full_promo?: SortOrder
    course_material_id?: SortOrder
    session_type_course_material?: course_materialOrderByWithRelationInput
    session_type_slot?: slotOrderByRelationAggregateInput
  }

  export type session_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: session_typeWhereInput | session_typeWhereInput[]
    OR?: session_typeWhereInput[]
    NOT?: session_typeWhereInput | session_typeWhereInput[]
    course_type_name?: StringFilter<"session_type"> | string
    nb_repetitions?: IntFilter<"session_type"> | number
    full_promo?: BoolFilter<"session_type"> | boolean
    course_material_id?: StringFilter<"session_type"> | string
    session_type_course_material?: XOR<Course_materialScalarRelationFilter, course_materialWhereInput>
    session_type_slot?: SlotListRelationFilter
  }, "id">

  export type session_typeOrderByWithAggregationInput = {
    id?: SortOrder
    course_type_name?: SortOrder
    nb_repetitions?: SortOrder
    full_promo?: SortOrder
    course_material_id?: SortOrder
    _count?: session_typeCountOrderByAggregateInput
    _avg?: session_typeAvgOrderByAggregateInput
    _max?: session_typeMaxOrderByAggregateInput
    _min?: session_typeMinOrderByAggregateInput
    _sum?: session_typeSumOrderByAggregateInput
  }

  export type session_typeScalarWhereWithAggregatesInput = {
    AND?: session_typeScalarWhereWithAggregatesInput | session_typeScalarWhereWithAggregatesInput[]
    OR?: session_typeScalarWhereWithAggregatesInput[]
    NOT?: session_typeScalarWhereWithAggregatesInput | session_typeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session_type"> | string
    course_type_name?: StringWithAggregatesFilter<"session_type"> | string
    nb_repetitions?: IntWithAggregatesFilter<"session_type"> | number
    full_promo?: BoolWithAggregatesFilter<"session_type"> | boolean
    course_material_id?: StringWithAggregatesFilter<"session_type"> | string
  }

  export type presenceWhereInput = {
    AND?: presenceWhereInput | presenceWhereInput[]
    OR?: presenceWhereInput[]
    NOT?: presenceWhereInput | presenceWhereInput[]
    student_id?: StringFilter<"presence"> | string
    slot_id?: StringFilter<"presence"> | string
    presence_student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    presence_slot?: XOR<SlotScalarRelationFilter, slotWhereInput>
  }

  export type presenceOrderByWithRelationInput = {
    student_id?: SortOrder
    slot_id?: SortOrder
    presence_student?: studentOrderByWithRelationInput
    presence_slot?: slotOrderByWithRelationInput
  }

  export type presenceWhereUniqueInput = Prisma.AtLeast<{
    student_id_slot_id?: presenceStudent_idSlot_idCompoundUniqueInput
    AND?: presenceWhereInput | presenceWhereInput[]
    OR?: presenceWhereInput[]
    NOT?: presenceWhereInput | presenceWhereInput[]
    student_id?: StringFilter<"presence"> | string
    slot_id?: StringFilter<"presence"> | string
    presence_student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    presence_slot?: XOR<SlotScalarRelationFilter, slotWhereInput>
  }, "student_id_slot_id">

  export type presenceOrderByWithAggregationInput = {
    student_id?: SortOrder
    slot_id?: SortOrder
    _count?: presenceCountOrderByAggregateInput
    _max?: presenceMaxOrderByAggregateInput
    _min?: presenceMinOrderByAggregateInput
  }

  export type presenceScalarWhereWithAggregatesInput = {
    AND?: presenceScalarWhereWithAggregatesInput | presenceScalarWhereWithAggregatesInput[]
    OR?: presenceScalarWhereWithAggregatesInput[]
    NOT?: presenceScalarWhereWithAggregatesInput | presenceScalarWhereWithAggregatesInput[]
    student_id?: StringWithAggregatesFilter<"presence"> | string
    slot_id?: StringWithAggregatesFilter<"presence"> | string
  }

  export type slotWhereInput = {
    AND?: slotWhereInput | slotWhereInput[]
    OR?: slotWhereInput[]
    NOT?: slotWhereInput | slotWhereInput[]
    id?: StringFilter<"slot"> | string
    starting_time?: DateTimeFilter<"slot"> | Date | string
    date?: DateTimeFilter<"slot"> | Date | string
    num_session?: IntFilter<"slot"> | number
    group_id?: StringFilter<"slot"> | string
    supervisor_id?: StringFilter<"slot"> | string
    session_type_id?: StringFilter<"slot"> | string
    slot_presence?: PresenceListRelationFilter
    slot_group?: XOR<GroupScalarRelationFilter, groupWhereInput>
    slot_supervisor?: XOR<SupervisorScalarRelationFilter, supervisorWhereInput>
    slot_seesion_type?: XOR<Session_typeScalarRelationFilter, session_typeWhereInput>
  }

  export type slotOrderByWithRelationInput = {
    id?: SortOrder
    starting_time?: SortOrder
    date?: SortOrder
    num_session?: SortOrder
    group_id?: SortOrder
    supervisor_id?: SortOrder
    session_type_id?: SortOrder
    slot_presence?: presenceOrderByRelationAggregateInput
    slot_group?: groupOrderByWithRelationInput
    slot_supervisor?: supervisorOrderByWithRelationInput
    slot_seesion_type?: session_typeOrderByWithRelationInput
  }

  export type slotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: slotWhereInput | slotWhereInput[]
    OR?: slotWhereInput[]
    NOT?: slotWhereInput | slotWhereInput[]
    starting_time?: DateTimeFilter<"slot"> | Date | string
    date?: DateTimeFilter<"slot"> | Date | string
    num_session?: IntFilter<"slot"> | number
    group_id?: StringFilter<"slot"> | string
    supervisor_id?: StringFilter<"slot"> | string
    session_type_id?: StringFilter<"slot"> | string
    slot_presence?: PresenceListRelationFilter
    slot_group?: XOR<GroupScalarRelationFilter, groupWhereInput>
    slot_supervisor?: XOR<SupervisorScalarRelationFilter, supervisorWhereInput>
    slot_seesion_type?: XOR<Session_typeScalarRelationFilter, session_typeWhereInput>
  }, "id">

  export type slotOrderByWithAggregationInput = {
    id?: SortOrder
    starting_time?: SortOrder
    date?: SortOrder
    num_session?: SortOrder
    group_id?: SortOrder
    supervisor_id?: SortOrder
    session_type_id?: SortOrder
    _count?: slotCountOrderByAggregateInput
    _avg?: slotAvgOrderByAggregateInput
    _max?: slotMaxOrderByAggregateInput
    _min?: slotMinOrderByAggregateInput
    _sum?: slotSumOrderByAggregateInput
  }

  export type slotScalarWhereWithAggregatesInput = {
    AND?: slotScalarWhereWithAggregatesInput | slotScalarWhereWithAggregatesInput[]
    OR?: slotScalarWhereWithAggregatesInput[]
    NOT?: slotScalarWhereWithAggregatesInput | slotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"slot"> | string
    starting_time?: DateTimeWithAggregatesFilter<"slot"> | Date | string
    date?: DateTimeWithAggregatesFilter<"slot"> | Date | string
    num_session?: IntWithAggregatesFilter<"slot"> | number
    group_id?: StringWithAggregatesFilter<"slot"> | string
    supervisor_id?: StringWithAggregatesFilter<"slot"> | string
    session_type_id?: StringWithAggregatesFilter<"slot"> | string
  }

  export type supervisorCreateInput = {
    id: string
    name: string
    mail: string
    supervisor_slot?: slotCreateNestedManyWithoutSlot_supervisorInput
  }

  export type supervisorUncheckedCreateInput = {
    id: string
    name: string
    mail: string
    supervisor_slot?: slotUncheckedCreateNestedManyWithoutSlot_supervisorInput
  }

  export type supervisorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    supervisor_slot?: slotUpdateManyWithoutSlot_supervisorNestedInput
  }

  export type supervisorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    supervisor_slot?: slotUncheckedUpdateManyWithoutSlot_supervisorNestedInput
  }

  export type supervisorCreateManyInput = {
    id: string
    name: string
    mail: string
  }

  export type supervisorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
  }

  export type supervisorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
  }

  export type studentCreateInput = {
    id: string
    name: string
    first_name: string
    mail: string
    student_inscription?: inscriptionCreateNestedManyWithoutInscription_studentInput
    student_presence?: presenceCreateNestedManyWithoutPresence_studentInput
  }

  export type studentUncheckedCreateInput = {
    id: string
    name: string
    first_name: string
    mail: string
    student_inscription?: inscriptionUncheckedCreateNestedManyWithoutInscription_studentInput
    student_presence?: presenceUncheckedCreateNestedManyWithoutPresence_studentInput
  }

  export type studentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    student_inscription?: inscriptionUpdateManyWithoutInscription_studentNestedInput
    student_presence?: presenceUpdateManyWithoutPresence_studentNestedInput
  }

  export type studentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    student_inscription?: inscriptionUncheckedUpdateManyWithoutInscription_studentNestedInput
    student_presence?: presenceUncheckedUpdateManyWithoutPresence_studentNestedInput
  }

  export type studentCreateManyInput = {
    id: string
    name: string
    first_name: string
    mail: string
  }

  export type studentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
  }

  export type studentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
  }

  export type inscriptionCreateInput = {
    inscription_student: studentCreateNestedOneWithoutStudent_inscriptionInput
    inscription_group: groupCreateNestedOneWithoutGroup_inscriptionInput
  }

  export type inscriptionUncheckedCreateInput = {
    student_id: string
    group_id: string
  }

  export type inscriptionUpdateInput = {
    inscription_student?: studentUpdateOneRequiredWithoutStudent_inscriptionNestedInput
    inscription_group?: groupUpdateOneRequiredWithoutGroup_inscriptionNestedInput
  }

  export type inscriptionUncheckedUpdateInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type inscriptionCreateManyInput = {
    student_id: string
    group_id: string
  }

  export type inscriptionUpdateManyMutationInput = {

  }

  export type inscriptionUncheckedUpdateManyInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type groupCreateInput = {
    id: string
    name: string
    group_semester: semesterCreateNestedOneWithoutSemester_groupInput
    group_inscription?: inscriptionCreateNestedManyWithoutInscription_groupInput
    group_slot?: slotCreateNestedManyWithoutSlot_groupInput
  }

  export type groupUncheckedCreateInput = {
    id: string
    name: string
    semester_id: string
    group_inscription?: inscriptionUncheckedCreateNestedManyWithoutInscription_groupInput
    group_slot?: slotUncheckedCreateNestedManyWithoutSlot_groupInput
  }

  export type groupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group_semester?: semesterUpdateOneRequiredWithoutSemester_groupNestedInput
    group_inscription?: inscriptionUpdateManyWithoutInscription_groupNestedInput
    group_slot?: slotUpdateManyWithoutSlot_groupNestedInput
  }

  export type groupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester_id?: StringFieldUpdateOperationsInput | string
    group_inscription?: inscriptionUncheckedUpdateManyWithoutInscription_groupNestedInput
    group_slot?: slotUncheckedUpdateManyWithoutSlot_groupNestedInput
  }

  export type groupCreateManyInput = {
    id: string
    name: string
    semester_id: string
  }

  export type groupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type groupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester_id?: StringFieldUpdateOperationsInput | string
  }

  export type semesterCreateInput = {
    id: string
    year: Date | string
    name: string
    semester_group?: groupCreateNestedManyWithoutGroup_semesterInput
    semester_course_material?: course_materialCreateNestedManyWithoutCourse_material_semesterInput
  }

  export type semesterUncheckedCreateInput = {
    id: string
    year: Date | string
    name: string
    semester_group?: groupUncheckedCreateNestedManyWithoutGroup_semesterInput
    semester_course_material?: course_materialUncheckedCreateNestedManyWithoutCourse_material_semesterInput
  }

  export type semesterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    semester_group?: groupUpdateManyWithoutGroup_semesterNestedInput
    semester_course_material?: course_materialUpdateManyWithoutCourse_material_semesterNestedInput
  }

  export type semesterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    semester_group?: groupUncheckedUpdateManyWithoutGroup_semesterNestedInput
    semester_course_material?: course_materialUncheckedUpdateManyWithoutCourse_material_semesterNestedInput
  }

  export type semesterCreateManyInput = {
    id: string
    year: Date | string
    name: string
  }

  export type semesterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type semesterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type course_materialCreateInput = {
    id: string
    name: string
    course_material_semester: semesterCreateNestedOneWithoutSemester_course_materialInput
    course_material_session_type?: session_typeCreateNestedManyWithoutSession_type_course_materialInput
  }

  export type course_materialUncheckedCreateInput = {
    id: string
    name: string
    semester_id: string
    course_material_session_type?: session_typeUncheckedCreateNestedManyWithoutSession_type_course_materialInput
  }

  export type course_materialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course_material_semester?: semesterUpdateOneRequiredWithoutSemester_course_materialNestedInput
    course_material_session_type?: session_typeUpdateManyWithoutSession_type_course_materialNestedInput
  }

  export type course_materialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester_id?: StringFieldUpdateOperationsInput | string
    course_material_session_type?: session_typeUncheckedUpdateManyWithoutSession_type_course_materialNestedInput
  }

  export type course_materialCreateManyInput = {
    id: string
    name: string
    semester_id: string
  }

  export type course_materialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type course_materialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester_id?: StringFieldUpdateOperationsInput | string
  }

  export type session_typeCreateInput = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
    session_type_course_material: course_materialCreateNestedOneWithoutCourse_material_session_typeInput
    session_type_slot?: slotCreateNestedManyWithoutSlot_seesion_typeInput
  }

  export type session_typeUncheckedCreateInput = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
    course_material_id: string
    session_type_slot?: slotUncheckedCreateNestedManyWithoutSlot_seesion_typeInput
  }

  export type session_typeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
    session_type_course_material?: course_materialUpdateOneRequiredWithoutCourse_material_session_typeNestedInput
    session_type_slot?: slotUpdateManyWithoutSlot_seesion_typeNestedInput
  }

  export type session_typeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
    course_material_id?: StringFieldUpdateOperationsInput | string
    session_type_slot?: slotUncheckedUpdateManyWithoutSlot_seesion_typeNestedInput
  }

  export type session_typeCreateManyInput = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
    course_material_id: string
  }

  export type session_typeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type session_typeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
    course_material_id?: StringFieldUpdateOperationsInput | string
  }

  export type presenceCreateInput = {
    presence_student: studentCreateNestedOneWithoutStudent_presenceInput
    presence_slot: slotCreateNestedOneWithoutSlot_presenceInput
  }

  export type presenceUncheckedCreateInput = {
    student_id: string
    slot_id: string
  }

  export type presenceUpdateInput = {
    presence_student?: studentUpdateOneRequiredWithoutStudent_presenceNestedInput
    presence_slot?: slotUpdateOneRequiredWithoutSlot_presenceNestedInput
  }

  export type presenceUncheckedUpdateInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    slot_id?: StringFieldUpdateOperationsInput | string
  }

  export type presenceCreateManyInput = {
    student_id: string
    slot_id: string
  }

  export type presenceUpdateManyMutationInput = {

  }

  export type presenceUncheckedUpdateManyInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    slot_id?: StringFieldUpdateOperationsInput | string
  }

  export type slotCreateInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    slot_presence?: presenceCreateNestedManyWithoutPresence_slotInput
    slot_group: groupCreateNestedOneWithoutGroup_slotInput
    slot_supervisor: supervisorCreateNestedOneWithoutSupervisor_slotInput
    slot_seesion_type: session_typeCreateNestedOneWithoutSession_type_slotInput
  }

  export type slotUncheckedCreateInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    group_id: string
    supervisor_id: string
    session_type_id: string
    slot_presence?: presenceUncheckedCreateNestedManyWithoutPresence_slotInput
  }

  export type slotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    slot_presence?: presenceUpdateManyWithoutPresence_slotNestedInput
    slot_group?: groupUpdateOneRequiredWithoutGroup_slotNestedInput
    slot_supervisor?: supervisorUpdateOneRequiredWithoutSupervisor_slotNestedInput
    slot_seesion_type?: session_typeUpdateOneRequiredWithoutSession_type_slotNestedInput
  }

  export type slotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    session_type_id?: StringFieldUpdateOperationsInput | string
    slot_presence?: presenceUncheckedUpdateManyWithoutPresence_slotNestedInput
  }

  export type slotCreateManyInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    group_id: string
    supervisor_id: string
    session_type_id: string
  }

  export type slotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
  }

  export type slotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    session_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SlotListRelationFilter = {
    every?: slotWhereInput
    some?: slotWhereInput
    none?: slotWhereInput
  }

  export type slotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type supervisorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mail?: SortOrder
  }

  export type supervisorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mail?: SortOrder
  }

  export type supervisorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mail?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type InscriptionListRelationFilter = {
    every?: inscriptionWhereInput
    some?: inscriptionWhereInput
    none?: inscriptionWhereInput
  }

  export type PresenceListRelationFilter = {
    every?: presenceWhereInput
    some?: presenceWhereInput
    none?: presenceWhereInput
  }

  export type inscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type presenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    mail?: SortOrder
  }

  export type studentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    mail?: SortOrder
  }

  export type studentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    first_name?: SortOrder
    mail?: SortOrder
  }

  export type StudentScalarRelationFilter = {
    is?: studentWhereInput
    isNot?: studentWhereInput
  }

  export type GroupScalarRelationFilter = {
    is?: groupWhereInput
    isNot?: groupWhereInput
  }

  export type inscriptionStudent_idGroup_idCompoundUniqueInput = {
    student_id: string
    group_id: string
  }

  export type inscriptionCountOrderByAggregateInput = {
    student_id?: SortOrder
    group_id?: SortOrder
  }

  export type inscriptionMaxOrderByAggregateInput = {
    student_id?: SortOrder
    group_id?: SortOrder
  }

  export type inscriptionMinOrderByAggregateInput = {
    student_id?: SortOrder
    group_id?: SortOrder
  }

  export type SemesterScalarRelationFilter = {
    is?: semesterWhereInput
    isNot?: semesterWhereInput
  }

  export type groupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
  }

  export type groupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
  }

  export type groupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type GroupListRelationFilter = {
    every?: groupWhereInput
    some?: groupWhereInput
    none?: groupWhereInput
  }

  export type Course_materialListRelationFilter = {
    every?: course_materialWhereInput
    some?: course_materialWhereInput
    none?: course_materialWhereInput
  }

  export type groupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type course_materialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type semesterCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    name?: SortOrder
  }

  export type semesterMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    name?: SortOrder
  }

  export type semesterMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    name?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Session_typeListRelationFilter = {
    every?: session_typeWhereInput
    some?: session_typeWhereInput
    none?: session_typeWhereInput
  }

  export type session_typeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type course_materialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
  }

  export type course_materialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
  }

  export type course_materialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    semester_id?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Course_materialScalarRelationFilter = {
    is?: course_materialWhereInput
    isNot?: course_materialWhereInput
  }

  export type session_typeCountOrderByAggregateInput = {
    id?: SortOrder
    course_type_name?: SortOrder
    nb_repetitions?: SortOrder
    full_promo?: SortOrder
    course_material_id?: SortOrder
  }

  export type session_typeAvgOrderByAggregateInput = {
    nb_repetitions?: SortOrder
  }

  export type session_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    course_type_name?: SortOrder
    nb_repetitions?: SortOrder
    full_promo?: SortOrder
    course_material_id?: SortOrder
  }

  export type session_typeMinOrderByAggregateInput = {
    id?: SortOrder
    course_type_name?: SortOrder
    nb_repetitions?: SortOrder
    full_promo?: SortOrder
    course_material_id?: SortOrder
  }

  export type session_typeSumOrderByAggregateInput = {
    nb_repetitions?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SlotScalarRelationFilter = {
    is?: slotWhereInput
    isNot?: slotWhereInput
  }

  export type presenceStudent_idSlot_idCompoundUniqueInput = {
    student_id: string
    slot_id: string
  }

  export type presenceCountOrderByAggregateInput = {
    student_id?: SortOrder
    slot_id?: SortOrder
  }

  export type presenceMaxOrderByAggregateInput = {
    student_id?: SortOrder
    slot_id?: SortOrder
  }

  export type presenceMinOrderByAggregateInput = {
    student_id?: SortOrder
    slot_id?: SortOrder
  }

  export type SupervisorScalarRelationFilter = {
    is?: supervisorWhereInput
    isNot?: supervisorWhereInput
  }

  export type Session_typeScalarRelationFilter = {
    is?: session_typeWhereInput
    isNot?: session_typeWhereInput
  }

  export type slotCountOrderByAggregateInput = {
    id?: SortOrder
    starting_time?: SortOrder
    date?: SortOrder
    num_session?: SortOrder
    group_id?: SortOrder
    supervisor_id?: SortOrder
    session_type_id?: SortOrder
  }

  export type slotAvgOrderByAggregateInput = {
    num_session?: SortOrder
  }

  export type slotMaxOrderByAggregateInput = {
    id?: SortOrder
    starting_time?: SortOrder
    date?: SortOrder
    num_session?: SortOrder
    group_id?: SortOrder
    supervisor_id?: SortOrder
    session_type_id?: SortOrder
  }

  export type slotMinOrderByAggregateInput = {
    id?: SortOrder
    starting_time?: SortOrder
    date?: SortOrder
    num_session?: SortOrder
    group_id?: SortOrder
    supervisor_id?: SortOrder
    session_type_id?: SortOrder
  }

  export type slotSumOrderByAggregateInput = {
    num_session?: SortOrder
  }

  export type slotCreateNestedManyWithoutSlot_supervisorInput = {
    create?: XOR<slotCreateWithoutSlot_supervisorInput, slotUncheckedCreateWithoutSlot_supervisorInput> | slotCreateWithoutSlot_supervisorInput[] | slotUncheckedCreateWithoutSlot_supervisorInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_supervisorInput | slotCreateOrConnectWithoutSlot_supervisorInput[]
    createMany?: slotCreateManySlot_supervisorInputEnvelope
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
  }

  export type slotUncheckedCreateNestedManyWithoutSlot_supervisorInput = {
    create?: XOR<slotCreateWithoutSlot_supervisorInput, slotUncheckedCreateWithoutSlot_supervisorInput> | slotCreateWithoutSlot_supervisorInput[] | slotUncheckedCreateWithoutSlot_supervisorInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_supervisorInput | slotCreateOrConnectWithoutSlot_supervisorInput[]
    createMany?: slotCreateManySlot_supervisorInputEnvelope
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type slotUpdateManyWithoutSlot_supervisorNestedInput = {
    create?: XOR<slotCreateWithoutSlot_supervisorInput, slotUncheckedCreateWithoutSlot_supervisorInput> | slotCreateWithoutSlot_supervisorInput[] | slotUncheckedCreateWithoutSlot_supervisorInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_supervisorInput | slotCreateOrConnectWithoutSlot_supervisorInput[]
    upsert?: slotUpsertWithWhereUniqueWithoutSlot_supervisorInput | slotUpsertWithWhereUniqueWithoutSlot_supervisorInput[]
    createMany?: slotCreateManySlot_supervisorInputEnvelope
    set?: slotWhereUniqueInput | slotWhereUniqueInput[]
    disconnect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    delete?: slotWhereUniqueInput | slotWhereUniqueInput[]
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    update?: slotUpdateWithWhereUniqueWithoutSlot_supervisorInput | slotUpdateWithWhereUniqueWithoutSlot_supervisorInput[]
    updateMany?: slotUpdateManyWithWhereWithoutSlot_supervisorInput | slotUpdateManyWithWhereWithoutSlot_supervisorInput[]
    deleteMany?: slotScalarWhereInput | slotScalarWhereInput[]
  }

  export type slotUncheckedUpdateManyWithoutSlot_supervisorNestedInput = {
    create?: XOR<slotCreateWithoutSlot_supervisorInput, slotUncheckedCreateWithoutSlot_supervisorInput> | slotCreateWithoutSlot_supervisorInput[] | slotUncheckedCreateWithoutSlot_supervisorInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_supervisorInput | slotCreateOrConnectWithoutSlot_supervisorInput[]
    upsert?: slotUpsertWithWhereUniqueWithoutSlot_supervisorInput | slotUpsertWithWhereUniqueWithoutSlot_supervisorInput[]
    createMany?: slotCreateManySlot_supervisorInputEnvelope
    set?: slotWhereUniqueInput | slotWhereUniqueInput[]
    disconnect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    delete?: slotWhereUniqueInput | slotWhereUniqueInput[]
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    update?: slotUpdateWithWhereUniqueWithoutSlot_supervisorInput | slotUpdateWithWhereUniqueWithoutSlot_supervisorInput[]
    updateMany?: slotUpdateManyWithWhereWithoutSlot_supervisorInput | slotUpdateManyWithWhereWithoutSlot_supervisorInput[]
    deleteMany?: slotScalarWhereInput | slotScalarWhereInput[]
  }

  export type inscriptionCreateNestedManyWithoutInscription_studentInput = {
    create?: XOR<inscriptionCreateWithoutInscription_studentInput, inscriptionUncheckedCreateWithoutInscription_studentInput> | inscriptionCreateWithoutInscription_studentInput[] | inscriptionUncheckedCreateWithoutInscription_studentInput[]
    connectOrCreate?: inscriptionCreateOrConnectWithoutInscription_studentInput | inscriptionCreateOrConnectWithoutInscription_studentInput[]
    createMany?: inscriptionCreateManyInscription_studentInputEnvelope
    connect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
  }

  export type presenceCreateNestedManyWithoutPresence_studentInput = {
    create?: XOR<presenceCreateWithoutPresence_studentInput, presenceUncheckedCreateWithoutPresence_studentInput> | presenceCreateWithoutPresence_studentInput[] | presenceUncheckedCreateWithoutPresence_studentInput[]
    connectOrCreate?: presenceCreateOrConnectWithoutPresence_studentInput | presenceCreateOrConnectWithoutPresence_studentInput[]
    createMany?: presenceCreateManyPresence_studentInputEnvelope
    connect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
  }

  export type inscriptionUncheckedCreateNestedManyWithoutInscription_studentInput = {
    create?: XOR<inscriptionCreateWithoutInscription_studentInput, inscriptionUncheckedCreateWithoutInscription_studentInput> | inscriptionCreateWithoutInscription_studentInput[] | inscriptionUncheckedCreateWithoutInscription_studentInput[]
    connectOrCreate?: inscriptionCreateOrConnectWithoutInscription_studentInput | inscriptionCreateOrConnectWithoutInscription_studentInput[]
    createMany?: inscriptionCreateManyInscription_studentInputEnvelope
    connect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
  }

  export type presenceUncheckedCreateNestedManyWithoutPresence_studentInput = {
    create?: XOR<presenceCreateWithoutPresence_studentInput, presenceUncheckedCreateWithoutPresence_studentInput> | presenceCreateWithoutPresence_studentInput[] | presenceUncheckedCreateWithoutPresence_studentInput[]
    connectOrCreate?: presenceCreateOrConnectWithoutPresence_studentInput | presenceCreateOrConnectWithoutPresence_studentInput[]
    createMany?: presenceCreateManyPresence_studentInputEnvelope
    connect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
  }

  export type inscriptionUpdateManyWithoutInscription_studentNestedInput = {
    create?: XOR<inscriptionCreateWithoutInscription_studentInput, inscriptionUncheckedCreateWithoutInscription_studentInput> | inscriptionCreateWithoutInscription_studentInput[] | inscriptionUncheckedCreateWithoutInscription_studentInput[]
    connectOrCreate?: inscriptionCreateOrConnectWithoutInscription_studentInput | inscriptionCreateOrConnectWithoutInscription_studentInput[]
    upsert?: inscriptionUpsertWithWhereUniqueWithoutInscription_studentInput | inscriptionUpsertWithWhereUniqueWithoutInscription_studentInput[]
    createMany?: inscriptionCreateManyInscription_studentInputEnvelope
    set?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    disconnect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    delete?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    connect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    update?: inscriptionUpdateWithWhereUniqueWithoutInscription_studentInput | inscriptionUpdateWithWhereUniqueWithoutInscription_studentInput[]
    updateMany?: inscriptionUpdateManyWithWhereWithoutInscription_studentInput | inscriptionUpdateManyWithWhereWithoutInscription_studentInput[]
    deleteMany?: inscriptionScalarWhereInput | inscriptionScalarWhereInput[]
  }

  export type presenceUpdateManyWithoutPresence_studentNestedInput = {
    create?: XOR<presenceCreateWithoutPresence_studentInput, presenceUncheckedCreateWithoutPresence_studentInput> | presenceCreateWithoutPresence_studentInput[] | presenceUncheckedCreateWithoutPresence_studentInput[]
    connectOrCreate?: presenceCreateOrConnectWithoutPresence_studentInput | presenceCreateOrConnectWithoutPresence_studentInput[]
    upsert?: presenceUpsertWithWhereUniqueWithoutPresence_studentInput | presenceUpsertWithWhereUniqueWithoutPresence_studentInput[]
    createMany?: presenceCreateManyPresence_studentInputEnvelope
    set?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    disconnect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    delete?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    connect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    update?: presenceUpdateWithWhereUniqueWithoutPresence_studentInput | presenceUpdateWithWhereUniqueWithoutPresence_studentInput[]
    updateMany?: presenceUpdateManyWithWhereWithoutPresence_studentInput | presenceUpdateManyWithWhereWithoutPresence_studentInput[]
    deleteMany?: presenceScalarWhereInput | presenceScalarWhereInput[]
  }

  export type inscriptionUncheckedUpdateManyWithoutInscription_studentNestedInput = {
    create?: XOR<inscriptionCreateWithoutInscription_studentInput, inscriptionUncheckedCreateWithoutInscription_studentInput> | inscriptionCreateWithoutInscription_studentInput[] | inscriptionUncheckedCreateWithoutInscription_studentInput[]
    connectOrCreate?: inscriptionCreateOrConnectWithoutInscription_studentInput | inscriptionCreateOrConnectWithoutInscription_studentInput[]
    upsert?: inscriptionUpsertWithWhereUniqueWithoutInscription_studentInput | inscriptionUpsertWithWhereUniqueWithoutInscription_studentInput[]
    createMany?: inscriptionCreateManyInscription_studentInputEnvelope
    set?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    disconnect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    delete?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    connect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    update?: inscriptionUpdateWithWhereUniqueWithoutInscription_studentInput | inscriptionUpdateWithWhereUniqueWithoutInscription_studentInput[]
    updateMany?: inscriptionUpdateManyWithWhereWithoutInscription_studentInput | inscriptionUpdateManyWithWhereWithoutInscription_studentInput[]
    deleteMany?: inscriptionScalarWhereInput | inscriptionScalarWhereInput[]
  }

  export type presenceUncheckedUpdateManyWithoutPresence_studentNestedInput = {
    create?: XOR<presenceCreateWithoutPresence_studentInput, presenceUncheckedCreateWithoutPresence_studentInput> | presenceCreateWithoutPresence_studentInput[] | presenceUncheckedCreateWithoutPresence_studentInput[]
    connectOrCreate?: presenceCreateOrConnectWithoutPresence_studentInput | presenceCreateOrConnectWithoutPresence_studentInput[]
    upsert?: presenceUpsertWithWhereUniqueWithoutPresence_studentInput | presenceUpsertWithWhereUniqueWithoutPresence_studentInput[]
    createMany?: presenceCreateManyPresence_studentInputEnvelope
    set?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    disconnect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    delete?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    connect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    update?: presenceUpdateWithWhereUniqueWithoutPresence_studentInput | presenceUpdateWithWhereUniqueWithoutPresence_studentInput[]
    updateMany?: presenceUpdateManyWithWhereWithoutPresence_studentInput | presenceUpdateManyWithWhereWithoutPresence_studentInput[]
    deleteMany?: presenceScalarWhereInput | presenceScalarWhereInput[]
  }

  export type studentCreateNestedOneWithoutStudent_inscriptionInput = {
    create?: XOR<studentCreateWithoutStudent_inscriptionInput, studentUncheckedCreateWithoutStudent_inscriptionInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_inscriptionInput
    connect?: studentWhereUniqueInput
  }

  export type groupCreateNestedOneWithoutGroup_inscriptionInput = {
    create?: XOR<groupCreateWithoutGroup_inscriptionInput, groupUncheckedCreateWithoutGroup_inscriptionInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroup_inscriptionInput
    connect?: groupWhereUniqueInput
  }

  export type studentUpdateOneRequiredWithoutStudent_inscriptionNestedInput = {
    create?: XOR<studentCreateWithoutStudent_inscriptionInput, studentUncheckedCreateWithoutStudent_inscriptionInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_inscriptionInput
    upsert?: studentUpsertWithoutStudent_inscriptionInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutStudent_inscriptionInput, studentUpdateWithoutStudent_inscriptionInput>, studentUncheckedUpdateWithoutStudent_inscriptionInput>
  }

  export type groupUpdateOneRequiredWithoutGroup_inscriptionNestedInput = {
    create?: XOR<groupCreateWithoutGroup_inscriptionInput, groupUncheckedCreateWithoutGroup_inscriptionInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroup_inscriptionInput
    upsert?: groupUpsertWithoutGroup_inscriptionInput
    connect?: groupWhereUniqueInput
    update?: XOR<XOR<groupUpdateToOneWithWhereWithoutGroup_inscriptionInput, groupUpdateWithoutGroup_inscriptionInput>, groupUncheckedUpdateWithoutGroup_inscriptionInput>
  }

  export type semesterCreateNestedOneWithoutSemester_groupInput = {
    create?: XOR<semesterCreateWithoutSemester_groupInput, semesterUncheckedCreateWithoutSemester_groupInput>
    connectOrCreate?: semesterCreateOrConnectWithoutSemester_groupInput
    connect?: semesterWhereUniqueInput
  }

  export type inscriptionCreateNestedManyWithoutInscription_groupInput = {
    create?: XOR<inscriptionCreateWithoutInscription_groupInput, inscriptionUncheckedCreateWithoutInscription_groupInput> | inscriptionCreateWithoutInscription_groupInput[] | inscriptionUncheckedCreateWithoutInscription_groupInput[]
    connectOrCreate?: inscriptionCreateOrConnectWithoutInscription_groupInput | inscriptionCreateOrConnectWithoutInscription_groupInput[]
    createMany?: inscriptionCreateManyInscription_groupInputEnvelope
    connect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
  }

  export type slotCreateNestedManyWithoutSlot_groupInput = {
    create?: XOR<slotCreateWithoutSlot_groupInput, slotUncheckedCreateWithoutSlot_groupInput> | slotCreateWithoutSlot_groupInput[] | slotUncheckedCreateWithoutSlot_groupInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_groupInput | slotCreateOrConnectWithoutSlot_groupInput[]
    createMany?: slotCreateManySlot_groupInputEnvelope
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
  }

  export type inscriptionUncheckedCreateNestedManyWithoutInscription_groupInput = {
    create?: XOR<inscriptionCreateWithoutInscription_groupInput, inscriptionUncheckedCreateWithoutInscription_groupInput> | inscriptionCreateWithoutInscription_groupInput[] | inscriptionUncheckedCreateWithoutInscription_groupInput[]
    connectOrCreate?: inscriptionCreateOrConnectWithoutInscription_groupInput | inscriptionCreateOrConnectWithoutInscription_groupInput[]
    createMany?: inscriptionCreateManyInscription_groupInputEnvelope
    connect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
  }

  export type slotUncheckedCreateNestedManyWithoutSlot_groupInput = {
    create?: XOR<slotCreateWithoutSlot_groupInput, slotUncheckedCreateWithoutSlot_groupInput> | slotCreateWithoutSlot_groupInput[] | slotUncheckedCreateWithoutSlot_groupInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_groupInput | slotCreateOrConnectWithoutSlot_groupInput[]
    createMany?: slotCreateManySlot_groupInputEnvelope
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
  }

  export type semesterUpdateOneRequiredWithoutSemester_groupNestedInput = {
    create?: XOR<semesterCreateWithoutSemester_groupInput, semesterUncheckedCreateWithoutSemester_groupInput>
    connectOrCreate?: semesterCreateOrConnectWithoutSemester_groupInput
    upsert?: semesterUpsertWithoutSemester_groupInput
    connect?: semesterWhereUniqueInput
    update?: XOR<XOR<semesterUpdateToOneWithWhereWithoutSemester_groupInput, semesterUpdateWithoutSemester_groupInput>, semesterUncheckedUpdateWithoutSemester_groupInput>
  }

  export type inscriptionUpdateManyWithoutInscription_groupNestedInput = {
    create?: XOR<inscriptionCreateWithoutInscription_groupInput, inscriptionUncheckedCreateWithoutInscription_groupInput> | inscriptionCreateWithoutInscription_groupInput[] | inscriptionUncheckedCreateWithoutInscription_groupInput[]
    connectOrCreate?: inscriptionCreateOrConnectWithoutInscription_groupInput | inscriptionCreateOrConnectWithoutInscription_groupInput[]
    upsert?: inscriptionUpsertWithWhereUniqueWithoutInscription_groupInput | inscriptionUpsertWithWhereUniqueWithoutInscription_groupInput[]
    createMany?: inscriptionCreateManyInscription_groupInputEnvelope
    set?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    disconnect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    delete?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    connect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    update?: inscriptionUpdateWithWhereUniqueWithoutInscription_groupInput | inscriptionUpdateWithWhereUniqueWithoutInscription_groupInput[]
    updateMany?: inscriptionUpdateManyWithWhereWithoutInscription_groupInput | inscriptionUpdateManyWithWhereWithoutInscription_groupInput[]
    deleteMany?: inscriptionScalarWhereInput | inscriptionScalarWhereInput[]
  }

  export type slotUpdateManyWithoutSlot_groupNestedInput = {
    create?: XOR<slotCreateWithoutSlot_groupInput, slotUncheckedCreateWithoutSlot_groupInput> | slotCreateWithoutSlot_groupInput[] | slotUncheckedCreateWithoutSlot_groupInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_groupInput | slotCreateOrConnectWithoutSlot_groupInput[]
    upsert?: slotUpsertWithWhereUniqueWithoutSlot_groupInput | slotUpsertWithWhereUniqueWithoutSlot_groupInput[]
    createMany?: slotCreateManySlot_groupInputEnvelope
    set?: slotWhereUniqueInput | slotWhereUniqueInput[]
    disconnect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    delete?: slotWhereUniqueInput | slotWhereUniqueInput[]
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    update?: slotUpdateWithWhereUniqueWithoutSlot_groupInput | slotUpdateWithWhereUniqueWithoutSlot_groupInput[]
    updateMany?: slotUpdateManyWithWhereWithoutSlot_groupInput | slotUpdateManyWithWhereWithoutSlot_groupInput[]
    deleteMany?: slotScalarWhereInput | slotScalarWhereInput[]
  }

  export type inscriptionUncheckedUpdateManyWithoutInscription_groupNestedInput = {
    create?: XOR<inscriptionCreateWithoutInscription_groupInput, inscriptionUncheckedCreateWithoutInscription_groupInput> | inscriptionCreateWithoutInscription_groupInput[] | inscriptionUncheckedCreateWithoutInscription_groupInput[]
    connectOrCreate?: inscriptionCreateOrConnectWithoutInscription_groupInput | inscriptionCreateOrConnectWithoutInscription_groupInput[]
    upsert?: inscriptionUpsertWithWhereUniqueWithoutInscription_groupInput | inscriptionUpsertWithWhereUniqueWithoutInscription_groupInput[]
    createMany?: inscriptionCreateManyInscription_groupInputEnvelope
    set?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    disconnect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    delete?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    connect?: inscriptionWhereUniqueInput | inscriptionWhereUniqueInput[]
    update?: inscriptionUpdateWithWhereUniqueWithoutInscription_groupInput | inscriptionUpdateWithWhereUniqueWithoutInscription_groupInput[]
    updateMany?: inscriptionUpdateManyWithWhereWithoutInscription_groupInput | inscriptionUpdateManyWithWhereWithoutInscription_groupInput[]
    deleteMany?: inscriptionScalarWhereInput | inscriptionScalarWhereInput[]
  }

  export type slotUncheckedUpdateManyWithoutSlot_groupNestedInput = {
    create?: XOR<slotCreateWithoutSlot_groupInput, slotUncheckedCreateWithoutSlot_groupInput> | slotCreateWithoutSlot_groupInput[] | slotUncheckedCreateWithoutSlot_groupInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_groupInput | slotCreateOrConnectWithoutSlot_groupInput[]
    upsert?: slotUpsertWithWhereUniqueWithoutSlot_groupInput | slotUpsertWithWhereUniqueWithoutSlot_groupInput[]
    createMany?: slotCreateManySlot_groupInputEnvelope
    set?: slotWhereUniqueInput | slotWhereUniqueInput[]
    disconnect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    delete?: slotWhereUniqueInput | slotWhereUniqueInput[]
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    update?: slotUpdateWithWhereUniqueWithoutSlot_groupInput | slotUpdateWithWhereUniqueWithoutSlot_groupInput[]
    updateMany?: slotUpdateManyWithWhereWithoutSlot_groupInput | slotUpdateManyWithWhereWithoutSlot_groupInput[]
    deleteMany?: slotScalarWhereInput | slotScalarWhereInput[]
  }

  export type groupCreateNestedManyWithoutGroup_semesterInput = {
    create?: XOR<groupCreateWithoutGroup_semesterInput, groupUncheckedCreateWithoutGroup_semesterInput> | groupCreateWithoutGroup_semesterInput[] | groupUncheckedCreateWithoutGroup_semesterInput[]
    connectOrCreate?: groupCreateOrConnectWithoutGroup_semesterInput | groupCreateOrConnectWithoutGroup_semesterInput[]
    createMany?: groupCreateManyGroup_semesterInputEnvelope
    connect?: groupWhereUniqueInput | groupWhereUniqueInput[]
  }

  export type course_materialCreateNestedManyWithoutCourse_material_semesterInput = {
    create?: XOR<course_materialCreateWithoutCourse_material_semesterInput, course_materialUncheckedCreateWithoutCourse_material_semesterInput> | course_materialCreateWithoutCourse_material_semesterInput[] | course_materialUncheckedCreateWithoutCourse_material_semesterInput[]
    connectOrCreate?: course_materialCreateOrConnectWithoutCourse_material_semesterInput | course_materialCreateOrConnectWithoutCourse_material_semesterInput[]
    createMany?: course_materialCreateManyCourse_material_semesterInputEnvelope
    connect?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
  }

  export type groupUncheckedCreateNestedManyWithoutGroup_semesterInput = {
    create?: XOR<groupCreateWithoutGroup_semesterInput, groupUncheckedCreateWithoutGroup_semesterInput> | groupCreateWithoutGroup_semesterInput[] | groupUncheckedCreateWithoutGroup_semesterInput[]
    connectOrCreate?: groupCreateOrConnectWithoutGroup_semesterInput | groupCreateOrConnectWithoutGroup_semesterInput[]
    createMany?: groupCreateManyGroup_semesterInputEnvelope
    connect?: groupWhereUniqueInput | groupWhereUniqueInput[]
  }

  export type course_materialUncheckedCreateNestedManyWithoutCourse_material_semesterInput = {
    create?: XOR<course_materialCreateWithoutCourse_material_semesterInput, course_materialUncheckedCreateWithoutCourse_material_semesterInput> | course_materialCreateWithoutCourse_material_semesterInput[] | course_materialUncheckedCreateWithoutCourse_material_semesterInput[]
    connectOrCreate?: course_materialCreateOrConnectWithoutCourse_material_semesterInput | course_materialCreateOrConnectWithoutCourse_material_semesterInput[]
    createMany?: course_materialCreateManyCourse_material_semesterInputEnvelope
    connect?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type groupUpdateManyWithoutGroup_semesterNestedInput = {
    create?: XOR<groupCreateWithoutGroup_semesterInput, groupUncheckedCreateWithoutGroup_semesterInput> | groupCreateWithoutGroup_semesterInput[] | groupUncheckedCreateWithoutGroup_semesterInput[]
    connectOrCreate?: groupCreateOrConnectWithoutGroup_semesterInput | groupCreateOrConnectWithoutGroup_semesterInput[]
    upsert?: groupUpsertWithWhereUniqueWithoutGroup_semesterInput | groupUpsertWithWhereUniqueWithoutGroup_semesterInput[]
    createMany?: groupCreateManyGroup_semesterInputEnvelope
    set?: groupWhereUniqueInput | groupWhereUniqueInput[]
    disconnect?: groupWhereUniqueInput | groupWhereUniqueInput[]
    delete?: groupWhereUniqueInput | groupWhereUniqueInput[]
    connect?: groupWhereUniqueInput | groupWhereUniqueInput[]
    update?: groupUpdateWithWhereUniqueWithoutGroup_semesterInput | groupUpdateWithWhereUniqueWithoutGroup_semesterInput[]
    updateMany?: groupUpdateManyWithWhereWithoutGroup_semesterInput | groupUpdateManyWithWhereWithoutGroup_semesterInput[]
    deleteMany?: groupScalarWhereInput | groupScalarWhereInput[]
  }

  export type course_materialUpdateManyWithoutCourse_material_semesterNestedInput = {
    create?: XOR<course_materialCreateWithoutCourse_material_semesterInput, course_materialUncheckedCreateWithoutCourse_material_semesterInput> | course_materialCreateWithoutCourse_material_semesterInput[] | course_materialUncheckedCreateWithoutCourse_material_semesterInput[]
    connectOrCreate?: course_materialCreateOrConnectWithoutCourse_material_semesterInput | course_materialCreateOrConnectWithoutCourse_material_semesterInput[]
    upsert?: course_materialUpsertWithWhereUniqueWithoutCourse_material_semesterInput | course_materialUpsertWithWhereUniqueWithoutCourse_material_semesterInput[]
    createMany?: course_materialCreateManyCourse_material_semesterInputEnvelope
    set?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
    disconnect?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
    delete?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
    connect?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
    update?: course_materialUpdateWithWhereUniqueWithoutCourse_material_semesterInput | course_materialUpdateWithWhereUniqueWithoutCourse_material_semesterInput[]
    updateMany?: course_materialUpdateManyWithWhereWithoutCourse_material_semesterInput | course_materialUpdateManyWithWhereWithoutCourse_material_semesterInput[]
    deleteMany?: course_materialScalarWhereInput | course_materialScalarWhereInput[]
  }

  export type groupUncheckedUpdateManyWithoutGroup_semesterNestedInput = {
    create?: XOR<groupCreateWithoutGroup_semesterInput, groupUncheckedCreateWithoutGroup_semesterInput> | groupCreateWithoutGroup_semesterInput[] | groupUncheckedCreateWithoutGroup_semesterInput[]
    connectOrCreate?: groupCreateOrConnectWithoutGroup_semesterInput | groupCreateOrConnectWithoutGroup_semesterInput[]
    upsert?: groupUpsertWithWhereUniqueWithoutGroup_semesterInput | groupUpsertWithWhereUniqueWithoutGroup_semesterInput[]
    createMany?: groupCreateManyGroup_semesterInputEnvelope
    set?: groupWhereUniqueInput | groupWhereUniqueInput[]
    disconnect?: groupWhereUniqueInput | groupWhereUniqueInput[]
    delete?: groupWhereUniqueInput | groupWhereUniqueInput[]
    connect?: groupWhereUniqueInput | groupWhereUniqueInput[]
    update?: groupUpdateWithWhereUniqueWithoutGroup_semesterInput | groupUpdateWithWhereUniqueWithoutGroup_semesterInput[]
    updateMany?: groupUpdateManyWithWhereWithoutGroup_semesterInput | groupUpdateManyWithWhereWithoutGroup_semesterInput[]
    deleteMany?: groupScalarWhereInput | groupScalarWhereInput[]
  }

  export type course_materialUncheckedUpdateManyWithoutCourse_material_semesterNestedInput = {
    create?: XOR<course_materialCreateWithoutCourse_material_semesterInput, course_materialUncheckedCreateWithoutCourse_material_semesterInput> | course_materialCreateWithoutCourse_material_semesterInput[] | course_materialUncheckedCreateWithoutCourse_material_semesterInput[]
    connectOrCreate?: course_materialCreateOrConnectWithoutCourse_material_semesterInput | course_materialCreateOrConnectWithoutCourse_material_semesterInput[]
    upsert?: course_materialUpsertWithWhereUniqueWithoutCourse_material_semesterInput | course_materialUpsertWithWhereUniqueWithoutCourse_material_semesterInput[]
    createMany?: course_materialCreateManyCourse_material_semesterInputEnvelope
    set?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
    disconnect?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
    delete?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
    connect?: course_materialWhereUniqueInput | course_materialWhereUniqueInput[]
    update?: course_materialUpdateWithWhereUniqueWithoutCourse_material_semesterInput | course_materialUpdateWithWhereUniqueWithoutCourse_material_semesterInput[]
    updateMany?: course_materialUpdateManyWithWhereWithoutCourse_material_semesterInput | course_materialUpdateManyWithWhereWithoutCourse_material_semesterInput[]
    deleteMany?: course_materialScalarWhereInput | course_materialScalarWhereInput[]
  }

  export type semesterCreateNestedOneWithoutSemester_course_materialInput = {
    create?: XOR<semesterCreateWithoutSemester_course_materialInput, semesterUncheckedCreateWithoutSemester_course_materialInput>
    connectOrCreate?: semesterCreateOrConnectWithoutSemester_course_materialInput
    connect?: semesterWhereUniqueInput
  }

  export type session_typeCreateNestedManyWithoutSession_type_course_materialInput = {
    create?: XOR<session_typeCreateWithoutSession_type_course_materialInput, session_typeUncheckedCreateWithoutSession_type_course_materialInput> | session_typeCreateWithoutSession_type_course_materialInput[] | session_typeUncheckedCreateWithoutSession_type_course_materialInput[]
    connectOrCreate?: session_typeCreateOrConnectWithoutSession_type_course_materialInput | session_typeCreateOrConnectWithoutSession_type_course_materialInput[]
    createMany?: session_typeCreateManySession_type_course_materialInputEnvelope
    connect?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
  }

  export type session_typeUncheckedCreateNestedManyWithoutSession_type_course_materialInput = {
    create?: XOR<session_typeCreateWithoutSession_type_course_materialInput, session_typeUncheckedCreateWithoutSession_type_course_materialInput> | session_typeCreateWithoutSession_type_course_materialInput[] | session_typeUncheckedCreateWithoutSession_type_course_materialInput[]
    connectOrCreate?: session_typeCreateOrConnectWithoutSession_type_course_materialInput | session_typeCreateOrConnectWithoutSession_type_course_materialInput[]
    createMany?: session_typeCreateManySession_type_course_materialInputEnvelope
    connect?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
  }

  export type semesterUpdateOneRequiredWithoutSemester_course_materialNestedInput = {
    create?: XOR<semesterCreateWithoutSemester_course_materialInput, semesterUncheckedCreateWithoutSemester_course_materialInput>
    connectOrCreate?: semesterCreateOrConnectWithoutSemester_course_materialInput
    upsert?: semesterUpsertWithoutSemester_course_materialInput
    connect?: semesterWhereUniqueInput
    update?: XOR<XOR<semesterUpdateToOneWithWhereWithoutSemester_course_materialInput, semesterUpdateWithoutSemester_course_materialInput>, semesterUncheckedUpdateWithoutSemester_course_materialInput>
  }

  export type session_typeUpdateManyWithoutSession_type_course_materialNestedInput = {
    create?: XOR<session_typeCreateWithoutSession_type_course_materialInput, session_typeUncheckedCreateWithoutSession_type_course_materialInput> | session_typeCreateWithoutSession_type_course_materialInput[] | session_typeUncheckedCreateWithoutSession_type_course_materialInput[]
    connectOrCreate?: session_typeCreateOrConnectWithoutSession_type_course_materialInput | session_typeCreateOrConnectWithoutSession_type_course_materialInput[]
    upsert?: session_typeUpsertWithWhereUniqueWithoutSession_type_course_materialInput | session_typeUpsertWithWhereUniqueWithoutSession_type_course_materialInput[]
    createMany?: session_typeCreateManySession_type_course_materialInputEnvelope
    set?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
    disconnect?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
    delete?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
    connect?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
    update?: session_typeUpdateWithWhereUniqueWithoutSession_type_course_materialInput | session_typeUpdateWithWhereUniqueWithoutSession_type_course_materialInput[]
    updateMany?: session_typeUpdateManyWithWhereWithoutSession_type_course_materialInput | session_typeUpdateManyWithWhereWithoutSession_type_course_materialInput[]
    deleteMany?: session_typeScalarWhereInput | session_typeScalarWhereInput[]
  }

  export type session_typeUncheckedUpdateManyWithoutSession_type_course_materialNestedInput = {
    create?: XOR<session_typeCreateWithoutSession_type_course_materialInput, session_typeUncheckedCreateWithoutSession_type_course_materialInput> | session_typeCreateWithoutSession_type_course_materialInput[] | session_typeUncheckedCreateWithoutSession_type_course_materialInput[]
    connectOrCreate?: session_typeCreateOrConnectWithoutSession_type_course_materialInput | session_typeCreateOrConnectWithoutSession_type_course_materialInput[]
    upsert?: session_typeUpsertWithWhereUniqueWithoutSession_type_course_materialInput | session_typeUpsertWithWhereUniqueWithoutSession_type_course_materialInput[]
    createMany?: session_typeCreateManySession_type_course_materialInputEnvelope
    set?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
    disconnect?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
    delete?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
    connect?: session_typeWhereUniqueInput | session_typeWhereUniqueInput[]
    update?: session_typeUpdateWithWhereUniqueWithoutSession_type_course_materialInput | session_typeUpdateWithWhereUniqueWithoutSession_type_course_materialInput[]
    updateMany?: session_typeUpdateManyWithWhereWithoutSession_type_course_materialInput | session_typeUpdateManyWithWhereWithoutSession_type_course_materialInput[]
    deleteMany?: session_typeScalarWhereInput | session_typeScalarWhereInput[]
  }

  export type course_materialCreateNestedOneWithoutCourse_material_session_typeInput = {
    create?: XOR<course_materialCreateWithoutCourse_material_session_typeInput, course_materialUncheckedCreateWithoutCourse_material_session_typeInput>
    connectOrCreate?: course_materialCreateOrConnectWithoutCourse_material_session_typeInput
    connect?: course_materialWhereUniqueInput
  }

  export type slotCreateNestedManyWithoutSlot_seesion_typeInput = {
    create?: XOR<slotCreateWithoutSlot_seesion_typeInput, slotUncheckedCreateWithoutSlot_seesion_typeInput> | slotCreateWithoutSlot_seesion_typeInput[] | slotUncheckedCreateWithoutSlot_seesion_typeInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_seesion_typeInput | slotCreateOrConnectWithoutSlot_seesion_typeInput[]
    createMany?: slotCreateManySlot_seesion_typeInputEnvelope
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
  }

  export type slotUncheckedCreateNestedManyWithoutSlot_seesion_typeInput = {
    create?: XOR<slotCreateWithoutSlot_seesion_typeInput, slotUncheckedCreateWithoutSlot_seesion_typeInput> | slotCreateWithoutSlot_seesion_typeInput[] | slotUncheckedCreateWithoutSlot_seesion_typeInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_seesion_typeInput | slotCreateOrConnectWithoutSlot_seesion_typeInput[]
    createMany?: slotCreateManySlot_seesion_typeInputEnvelope
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type course_materialUpdateOneRequiredWithoutCourse_material_session_typeNestedInput = {
    create?: XOR<course_materialCreateWithoutCourse_material_session_typeInput, course_materialUncheckedCreateWithoutCourse_material_session_typeInput>
    connectOrCreate?: course_materialCreateOrConnectWithoutCourse_material_session_typeInput
    upsert?: course_materialUpsertWithoutCourse_material_session_typeInput
    connect?: course_materialWhereUniqueInput
    update?: XOR<XOR<course_materialUpdateToOneWithWhereWithoutCourse_material_session_typeInput, course_materialUpdateWithoutCourse_material_session_typeInput>, course_materialUncheckedUpdateWithoutCourse_material_session_typeInput>
  }

  export type slotUpdateManyWithoutSlot_seesion_typeNestedInput = {
    create?: XOR<slotCreateWithoutSlot_seesion_typeInput, slotUncheckedCreateWithoutSlot_seesion_typeInput> | slotCreateWithoutSlot_seesion_typeInput[] | slotUncheckedCreateWithoutSlot_seesion_typeInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_seesion_typeInput | slotCreateOrConnectWithoutSlot_seesion_typeInput[]
    upsert?: slotUpsertWithWhereUniqueWithoutSlot_seesion_typeInput | slotUpsertWithWhereUniqueWithoutSlot_seesion_typeInput[]
    createMany?: slotCreateManySlot_seesion_typeInputEnvelope
    set?: slotWhereUniqueInput | slotWhereUniqueInput[]
    disconnect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    delete?: slotWhereUniqueInput | slotWhereUniqueInput[]
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    update?: slotUpdateWithWhereUniqueWithoutSlot_seesion_typeInput | slotUpdateWithWhereUniqueWithoutSlot_seesion_typeInput[]
    updateMany?: slotUpdateManyWithWhereWithoutSlot_seesion_typeInput | slotUpdateManyWithWhereWithoutSlot_seesion_typeInput[]
    deleteMany?: slotScalarWhereInput | slotScalarWhereInput[]
  }

  export type slotUncheckedUpdateManyWithoutSlot_seesion_typeNestedInput = {
    create?: XOR<slotCreateWithoutSlot_seesion_typeInput, slotUncheckedCreateWithoutSlot_seesion_typeInput> | slotCreateWithoutSlot_seesion_typeInput[] | slotUncheckedCreateWithoutSlot_seesion_typeInput[]
    connectOrCreate?: slotCreateOrConnectWithoutSlot_seesion_typeInput | slotCreateOrConnectWithoutSlot_seesion_typeInput[]
    upsert?: slotUpsertWithWhereUniqueWithoutSlot_seesion_typeInput | slotUpsertWithWhereUniqueWithoutSlot_seesion_typeInput[]
    createMany?: slotCreateManySlot_seesion_typeInputEnvelope
    set?: slotWhereUniqueInput | slotWhereUniqueInput[]
    disconnect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    delete?: slotWhereUniqueInput | slotWhereUniqueInput[]
    connect?: slotWhereUniqueInput | slotWhereUniqueInput[]
    update?: slotUpdateWithWhereUniqueWithoutSlot_seesion_typeInput | slotUpdateWithWhereUniqueWithoutSlot_seesion_typeInput[]
    updateMany?: slotUpdateManyWithWhereWithoutSlot_seesion_typeInput | slotUpdateManyWithWhereWithoutSlot_seesion_typeInput[]
    deleteMany?: slotScalarWhereInput | slotScalarWhereInput[]
  }

  export type studentCreateNestedOneWithoutStudent_presenceInput = {
    create?: XOR<studentCreateWithoutStudent_presenceInput, studentUncheckedCreateWithoutStudent_presenceInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_presenceInput
    connect?: studentWhereUniqueInput
  }

  export type slotCreateNestedOneWithoutSlot_presenceInput = {
    create?: XOR<slotCreateWithoutSlot_presenceInput, slotUncheckedCreateWithoutSlot_presenceInput>
    connectOrCreate?: slotCreateOrConnectWithoutSlot_presenceInput
    connect?: slotWhereUniqueInput
  }

  export type studentUpdateOneRequiredWithoutStudent_presenceNestedInput = {
    create?: XOR<studentCreateWithoutStudent_presenceInput, studentUncheckedCreateWithoutStudent_presenceInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_presenceInput
    upsert?: studentUpsertWithoutStudent_presenceInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutStudent_presenceInput, studentUpdateWithoutStudent_presenceInput>, studentUncheckedUpdateWithoutStudent_presenceInput>
  }

  export type slotUpdateOneRequiredWithoutSlot_presenceNestedInput = {
    create?: XOR<slotCreateWithoutSlot_presenceInput, slotUncheckedCreateWithoutSlot_presenceInput>
    connectOrCreate?: slotCreateOrConnectWithoutSlot_presenceInput
    upsert?: slotUpsertWithoutSlot_presenceInput
    connect?: slotWhereUniqueInput
    update?: XOR<XOR<slotUpdateToOneWithWhereWithoutSlot_presenceInput, slotUpdateWithoutSlot_presenceInput>, slotUncheckedUpdateWithoutSlot_presenceInput>
  }

  export type presenceCreateNestedManyWithoutPresence_slotInput = {
    create?: XOR<presenceCreateWithoutPresence_slotInput, presenceUncheckedCreateWithoutPresence_slotInput> | presenceCreateWithoutPresence_slotInput[] | presenceUncheckedCreateWithoutPresence_slotInput[]
    connectOrCreate?: presenceCreateOrConnectWithoutPresence_slotInput | presenceCreateOrConnectWithoutPresence_slotInput[]
    createMany?: presenceCreateManyPresence_slotInputEnvelope
    connect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
  }

  export type groupCreateNestedOneWithoutGroup_slotInput = {
    create?: XOR<groupCreateWithoutGroup_slotInput, groupUncheckedCreateWithoutGroup_slotInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroup_slotInput
    connect?: groupWhereUniqueInput
  }

  export type supervisorCreateNestedOneWithoutSupervisor_slotInput = {
    create?: XOR<supervisorCreateWithoutSupervisor_slotInput, supervisorUncheckedCreateWithoutSupervisor_slotInput>
    connectOrCreate?: supervisorCreateOrConnectWithoutSupervisor_slotInput
    connect?: supervisorWhereUniqueInput
  }

  export type session_typeCreateNestedOneWithoutSession_type_slotInput = {
    create?: XOR<session_typeCreateWithoutSession_type_slotInput, session_typeUncheckedCreateWithoutSession_type_slotInput>
    connectOrCreate?: session_typeCreateOrConnectWithoutSession_type_slotInput
    connect?: session_typeWhereUniqueInput
  }

  export type presenceUncheckedCreateNestedManyWithoutPresence_slotInput = {
    create?: XOR<presenceCreateWithoutPresence_slotInput, presenceUncheckedCreateWithoutPresence_slotInput> | presenceCreateWithoutPresence_slotInput[] | presenceUncheckedCreateWithoutPresence_slotInput[]
    connectOrCreate?: presenceCreateOrConnectWithoutPresence_slotInput | presenceCreateOrConnectWithoutPresence_slotInput[]
    createMany?: presenceCreateManyPresence_slotInputEnvelope
    connect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
  }

  export type presenceUpdateManyWithoutPresence_slotNestedInput = {
    create?: XOR<presenceCreateWithoutPresence_slotInput, presenceUncheckedCreateWithoutPresence_slotInput> | presenceCreateWithoutPresence_slotInput[] | presenceUncheckedCreateWithoutPresence_slotInput[]
    connectOrCreate?: presenceCreateOrConnectWithoutPresence_slotInput | presenceCreateOrConnectWithoutPresence_slotInput[]
    upsert?: presenceUpsertWithWhereUniqueWithoutPresence_slotInput | presenceUpsertWithWhereUniqueWithoutPresence_slotInput[]
    createMany?: presenceCreateManyPresence_slotInputEnvelope
    set?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    disconnect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    delete?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    connect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    update?: presenceUpdateWithWhereUniqueWithoutPresence_slotInput | presenceUpdateWithWhereUniqueWithoutPresence_slotInput[]
    updateMany?: presenceUpdateManyWithWhereWithoutPresence_slotInput | presenceUpdateManyWithWhereWithoutPresence_slotInput[]
    deleteMany?: presenceScalarWhereInput | presenceScalarWhereInput[]
  }

  export type groupUpdateOneRequiredWithoutGroup_slotNestedInput = {
    create?: XOR<groupCreateWithoutGroup_slotInput, groupUncheckedCreateWithoutGroup_slotInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroup_slotInput
    upsert?: groupUpsertWithoutGroup_slotInput
    connect?: groupWhereUniqueInput
    update?: XOR<XOR<groupUpdateToOneWithWhereWithoutGroup_slotInput, groupUpdateWithoutGroup_slotInput>, groupUncheckedUpdateWithoutGroup_slotInput>
  }

  export type supervisorUpdateOneRequiredWithoutSupervisor_slotNestedInput = {
    create?: XOR<supervisorCreateWithoutSupervisor_slotInput, supervisorUncheckedCreateWithoutSupervisor_slotInput>
    connectOrCreate?: supervisorCreateOrConnectWithoutSupervisor_slotInput
    upsert?: supervisorUpsertWithoutSupervisor_slotInput
    connect?: supervisorWhereUniqueInput
    update?: XOR<XOR<supervisorUpdateToOneWithWhereWithoutSupervisor_slotInput, supervisorUpdateWithoutSupervisor_slotInput>, supervisorUncheckedUpdateWithoutSupervisor_slotInput>
  }

  export type session_typeUpdateOneRequiredWithoutSession_type_slotNestedInput = {
    create?: XOR<session_typeCreateWithoutSession_type_slotInput, session_typeUncheckedCreateWithoutSession_type_slotInput>
    connectOrCreate?: session_typeCreateOrConnectWithoutSession_type_slotInput
    upsert?: session_typeUpsertWithoutSession_type_slotInput
    connect?: session_typeWhereUniqueInput
    update?: XOR<XOR<session_typeUpdateToOneWithWhereWithoutSession_type_slotInput, session_typeUpdateWithoutSession_type_slotInput>, session_typeUncheckedUpdateWithoutSession_type_slotInput>
  }

  export type presenceUncheckedUpdateManyWithoutPresence_slotNestedInput = {
    create?: XOR<presenceCreateWithoutPresence_slotInput, presenceUncheckedCreateWithoutPresence_slotInput> | presenceCreateWithoutPresence_slotInput[] | presenceUncheckedCreateWithoutPresence_slotInput[]
    connectOrCreate?: presenceCreateOrConnectWithoutPresence_slotInput | presenceCreateOrConnectWithoutPresence_slotInput[]
    upsert?: presenceUpsertWithWhereUniqueWithoutPresence_slotInput | presenceUpsertWithWhereUniqueWithoutPresence_slotInput[]
    createMany?: presenceCreateManyPresence_slotInputEnvelope
    set?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    disconnect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    delete?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    connect?: presenceWhereUniqueInput | presenceWhereUniqueInput[]
    update?: presenceUpdateWithWhereUniqueWithoutPresence_slotInput | presenceUpdateWithWhereUniqueWithoutPresence_slotInput[]
    updateMany?: presenceUpdateManyWithWhereWithoutPresence_slotInput | presenceUpdateManyWithWhereWithoutPresence_slotInput[]
    deleteMany?: presenceScalarWhereInput | presenceScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type slotCreateWithoutSlot_supervisorInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    slot_presence?: presenceCreateNestedManyWithoutPresence_slotInput
    slot_group: groupCreateNestedOneWithoutGroup_slotInput
    slot_seesion_type: session_typeCreateNestedOneWithoutSession_type_slotInput
  }

  export type slotUncheckedCreateWithoutSlot_supervisorInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    group_id: string
    session_type_id: string
    slot_presence?: presenceUncheckedCreateNestedManyWithoutPresence_slotInput
  }

  export type slotCreateOrConnectWithoutSlot_supervisorInput = {
    where: slotWhereUniqueInput
    create: XOR<slotCreateWithoutSlot_supervisorInput, slotUncheckedCreateWithoutSlot_supervisorInput>
  }

  export type slotCreateManySlot_supervisorInputEnvelope = {
    data: slotCreateManySlot_supervisorInput | slotCreateManySlot_supervisorInput[]
  }

  export type slotUpsertWithWhereUniqueWithoutSlot_supervisorInput = {
    where: slotWhereUniqueInput
    update: XOR<slotUpdateWithoutSlot_supervisorInput, slotUncheckedUpdateWithoutSlot_supervisorInput>
    create: XOR<slotCreateWithoutSlot_supervisorInput, slotUncheckedCreateWithoutSlot_supervisorInput>
  }

  export type slotUpdateWithWhereUniqueWithoutSlot_supervisorInput = {
    where: slotWhereUniqueInput
    data: XOR<slotUpdateWithoutSlot_supervisorInput, slotUncheckedUpdateWithoutSlot_supervisorInput>
  }

  export type slotUpdateManyWithWhereWithoutSlot_supervisorInput = {
    where: slotScalarWhereInput
    data: XOR<slotUpdateManyMutationInput, slotUncheckedUpdateManyWithoutSlot_supervisorInput>
  }

  export type slotScalarWhereInput = {
    AND?: slotScalarWhereInput | slotScalarWhereInput[]
    OR?: slotScalarWhereInput[]
    NOT?: slotScalarWhereInput | slotScalarWhereInput[]
    id?: StringFilter<"slot"> | string
    starting_time?: DateTimeFilter<"slot"> | Date | string
    date?: DateTimeFilter<"slot"> | Date | string
    num_session?: IntFilter<"slot"> | number
    group_id?: StringFilter<"slot"> | string
    supervisor_id?: StringFilter<"slot"> | string
    session_type_id?: StringFilter<"slot"> | string
  }

  export type inscriptionCreateWithoutInscription_studentInput = {
    inscription_group: groupCreateNestedOneWithoutGroup_inscriptionInput
  }

  export type inscriptionUncheckedCreateWithoutInscription_studentInput = {
    group_id: string
  }

  export type inscriptionCreateOrConnectWithoutInscription_studentInput = {
    where: inscriptionWhereUniqueInput
    create: XOR<inscriptionCreateWithoutInscription_studentInput, inscriptionUncheckedCreateWithoutInscription_studentInput>
  }

  export type inscriptionCreateManyInscription_studentInputEnvelope = {
    data: inscriptionCreateManyInscription_studentInput | inscriptionCreateManyInscription_studentInput[]
  }

  export type presenceCreateWithoutPresence_studentInput = {
    presence_slot: slotCreateNestedOneWithoutSlot_presenceInput
  }

  export type presenceUncheckedCreateWithoutPresence_studentInput = {
    slot_id: string
  }

  export type presenceCreateOrConnectWithoutPresence_studentInput = {
    where: presenceWhereUniqueInput
    create: XOR<presenceCreateWithoutPresence_studentInput, presenceUncheckedCreateWithoutPresence_studentInput>
  }

  export type presenceCreateManyPresence_studentInputEnvelope = {
    data: presenceCreateManyPresence_studentInput | presenceCreateManyPresence_studentInput[]
  }

  export type inscriptionUpsertWithWhereUniqueWithoutInscription_studentInput = {
    where: inscriptionWhereUniqueInput
    update: XOR<inscriptionUpdateWithoutInscription_studentInput, inscriptionUncheckedUpdateWithoutInscription_studentInput>
    create: XOR<inscriptionCreateWithoutInscription_studentInput, inscriptionUncheckedCreateWithoutInscription_studentInput>
  }

  export type inscriptionUpdateWithWhereUniqueWithoutInscription_studentInput = {
    where: inscriptionWhereUniqueInput
    data: XOR<inscriptionUpdateWithoutInscription_studentInput, inscriptionUncheckedUpdateWithoutInscription_studentInput>
  }

  export type inscriptionUpdateManyWithWhereWithoutInscription_studentInput = {
    where: inscriptionScalarWhereInput
    data: XOR<inscriptionUpdateManyMutationInput, inscriptionUncheckedUpdateManyWithoutInscription_studentInput>
  }

  export type inscriptionScalarWhereInput = {
    AND?: inscriptionScalarWhereInput | inscriptionScalarWhereInput[]
    OR?: inscriptionScalarWhereInput[]
    NOT?: inscriptionScalarWhereInput | inscriptionScalarWhereInput[]
    student_id?: StringFilter<"inscription"> | string
    group_id?: StringFilter<"inscription"> | string
  }

  export type presenceUpsertWithWhereUniqueWithoutPresence_studentInput = {
    where: presenceWhereUniqueInput
    update: XOR<presenceUpdateWithoutPresence_studentInput, presenceUncheckedUpdateWithoutPresence_studentInput>
    create: XOR<presenceCreateWithoutPresence_studentInput, presenceUncheckedCreateWithoutPresence_studentInput>
  }

  export type presenceUpdateWithWhereUniqueWithoutPresence_studentInput = {
    where: presenceWhereUniqueInput
    data: XOR<presenceUpdateWithoutPresence_studentInput, presenceUncheckedUpdateWithoutPresence_studentInput>
  }

  export type presenceUpdateManyWithWhereWithoutPresence_studentInput = {
    where: presenceScalarWhereInput
    data: XOR<presenceUpdateManyMutationInput, presenceUncheckedUpdateManyWithoutPresence_studentInput>
  }

  export type presenceScalarWhereInput = {
    AND?: presenceScalarWhereInput | presenceScalarWhereInput[]
    OR?: presenceScalarWhereInput[]
    NOT?: presenceScalarWhereInput | presenceScalarWhereInput[]
    student_id?: StringFilter<"presence"> | string
    slot_id?: StringFilter<"presence"> | string
  }

  export type studentCreateWithoutStudent_inscriptionInput = {
    id: string
    name: string
    first_name: string
    mail: string
    student_presence?: presenceCreateNestedManyWithoutPresence_studentInput
  }

  export type studentUncheckedCreateWithoutStudent_inscriptionInput = {
    id: string
    name: string
    first_name: string
    mail: string
    student_presence?: presenceUncheckedCreateNestedManyWithoutPresence_studentInput
  }

  export type studentCreateOrConnectWithoutStudent_inscriptionInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutStudent_inscriptionInput, studentUncheckedCreateWithoutStudent_inscriptionInput>
  }

  export type groupCreateWithoutGroup_inscriptionInput = {
    id: string
    name: string
    group_semester: semesterCreateNestedOneWithoutSemester_groupInput
    group_slot?: slotCreateNestedManyWithoutSlot_groupInput
  }

  export type groupUncheckedCreateWithoutGroup_inscriptionInput = {
    id: string
    name: string
    semester_id: string
    group_slot?: slotUncheckedCreateNestedManyWithoutSlot_groupInput
  }

  export type groupCreateOrConnectWithoutGroup_inscriptionInput = {
    where: groupWhereUniqueInput
    create: XOR<groupCreateWithoutGroup_inscriptionInput, groupUncheckedCreateWithoutGroup_inscriptionInput>
  }

  export type studentUpsertWithoutStudent_inscriptionInput = {
    update: XOR<studentUpdateWithoutStudent_inscriptionInput, studentUncheckedUpdateWithoutStudent_inscriptionInput>
    create: XOR<studentCreateWithoutStudent_inscriptionInput, studentUncheckedCreateWithoutStudent_inscriptionInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutStudent_inscriptionInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutStudent_inscriptionInput, studentUncheckedUpdateWithoutStudent_inscriptionInput>
  }

  export type studentUpdateWithoutStudent_inscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    student_presence?: presenceUpdateManyWithoutPresence_studentNestedInput
  }

  export type studentUncheckedUpdateWithoutStudent_inscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    student_presence?: presenceUncheckedUpdateManyWithoutPresence_studentNestedInput
  }

  export type groupUpsertWithoutGroup_inscriptionInput = {
    update: XOR<groupUpdateWithoutGroup_inscriptionInput, groupUncheckedUpdateWithoutGroup_inscriptionInput>
    create: XOR<groupCreateWithoutGroup_inscriptionInput, groupUncheckedCreateWithoutGroup_inscriptionInput>
    where?: groupWhereInput
  }

  export type groupUpdateToOneWithWhereWithoutGroup_inscriptionInput = {
    where?: groupWhereInput
    data: XOR<groupUpdateWithoutGroup_inscriptionInput, groupUncheckedUpdateWithoutGroup_inscriptionInput>
  }

  export type groupUpdateWithoutGroup_inscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group_semester?: semesterUpdateOneRequiredWithoutSemester_groupNestedInput
    group_slot?: slotUpdateManyWithoutSlot_groupNestedInput
  }

  export type groupUncheckedUpdateWithoutGroup_inscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester_id?: StringFieldUpdateOperationsInput | string
    group_slot?: slotUncheckedUpdateManyWithoutSlot_groupNestedInput
  }

  export type semesterCreateWithoutSemester_groupInput = {
    id: string
    year: Date | string
    name: string
    semester_course_material?: course_materialCreateNestedManyWithoutCourse_material_semesterInput
  }

  export type semesterUncheckedCreateWithoutSemester_groupInput = {
    id: string
    year: Date | string
    name: string
    semester_course_material?: course_materialUncheckedCreateNestedManyWithoutCourse_material_semesterInput
  }

  export type semesterCreateOrConnectWithoutSemester_groupInput = {
    where: semesterWhereUniqueInput
    create: XOR<semesterCreateWithoutSemester_groupInput, semesterUncheckedCreateWithoutSemester_groupInput>
  }

  export type inscriptionCreateWithoutInscription_groupInput = {
    inscription_student: studentCreateNestedOneWithoutStudent_inscriptionInput
  }

  export type inscriptionUncheckedCreateWithoutInscription_groupInput = {
    student_id: string
  }

  export type inscriptionCreateOrConnectWithoutInscription_groupInput = {
    where: inscriptionWhereUniqueInput
    create: XOR<inscriptionCreateWithoutInscription_groupInput, inscriptionUncheckedCreateWithoutInscription_groupInput>
  }

  export type inscriptionCreateManyInscription_groupInputEnvelope = {
    data: inscriptionCreateManyInscription_groupInput | inscriptionCreateManyInscription_groupInput[]
  }

  export type slotCreateWithoutSlot_groupInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    slot_presence?: presenceCreateNestedManyWithoutPresence_slotInput
    slot_supervisor: supervisorCreateNestedOneWithoutSupervisor_slotInput
    slot_seesion_type: session_typeCreateNestedOneWithoutSession_type_slotInput
  }

  export type slotUncheckedCreateWithoutSlot_groupInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    supervisor_id: string
    session_type_id: string
    slot_presence?: presenceUncheckedCreateNestedManyWithoutPresence_slotInput
  }

  export type slotCreateOrConnectWithoutSlot_groupInput = {
    where: slotWhereUniqueInput
    create: XOR<slotCreateWithoutSlot_groupInput, slotUncheckedCreateWithoutSlot_groupInput>
  }

  export type slotCreateManySlot_groupInputEnvelope = {
    data: slotCreateManySlot_groupInput | slotCreateManySlot_groupInput[]
  }

  export type semesterUpsertWithoutSemester_groupInput = {
    update: XOR<semesterUpdateWithoutSemester_groupInput, semesterUncheckedUpdateWithoutSemester_groupInput>
    create: XOR<semesterCreateWithoutSemester_groupInput, semesterUncheckedCreateWithoutSemester_groupInput>
    where?: semesterWhereInput
  }

  export type semesterUpdateToOneWithWhereWithoutSemester_groupInput = {
    where?: semesterWhereInput
    data: XOR<semesterUpdateWithoutSemester_groupInput, semesterUncheckedUpdateWithoutSemester_groupInput>
  }

  export type semesterUpdateWithoutSemester_groupInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    semester_course_material?: course_materialUpdateManyWithoutCourse_material_semesterNestedInput
  }

  export type semesterUncheckedUpdateWithoutSemester_groupInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    semester_course_material?: course_materialUncheckedUpdateManyWithoutCourse_material_semesterNestedInput
  }

  export type inscriptionUpsertWithWhereUniqueWithoutInscription_groupInput = {
    where: inscriptionWhereUniqueInput
    update: XOR<inscriptionUpdateWithoutInscription_groupInput, inscriptionUncheckedUpdateWithoutInscription_groupInput>
    create: XOR<inscriptionCreateWithoutInscription_groupInput, inscriptionUncheckedCreateWithoutInscription_groupInput>
  }

  export type inscriptionUpdateWithWhereUniqueWithoutInscription_groupInput = {
    where: inscriptionWhereUniqueInput
    data: XOR<inscriptionUpdateWithoutInscription_groupInput, inscriptionUncheckedUpdateWithoutInscription_groupInput>
  }

  export type inscriptionUpdateManyWithWhereWithoutInscription_groupInput = {
    where: inscriptionScalarWhereInput
    data: XOR<inscriptionUpdateManyMutationInput, inscriptionUncheckedUpdateManyWithoutInscription_groupInput>
  }

  export type slotUpsertWithWhereUniqueWithoutSlot_groupInput = {
    where: slotWhereUniqueInput
    update: XOR<slotUpdateWithoutSlot_groupInput, slotUncheckedUpdateWithoutSlot_groupInput>
    create: XOR<slotCreateWithoutSlot_groupInput, slotUncheckedCreateWithoutSlot_groupInput>
  }

  export type slotUpdateWithWhereUniqueWithoutSlot_groupInput = {
    where: slotWhereUniqueInput
    data: XOR<slotUpdateWithoutSlot_groupInput, slotUncheckedUpdateWithoutSlot_groupInput>
  }

  export type slotUpdateManyWithWhereWithoutSlot_groupInput = {
    where: slotScalarWhereInput
    data: XOR<slotUpdateManyMutationInput, slotUncheckedUpdateManyWithoutSlot_groupInput>
  }

  export type groupCreateWithoutGroup_semesterInput = {
    id: string
    name: string
    group_inscription?: inscriptionCreateNestedManyWithoutInscription_groupInput
    group_slot?: slotCreateNestedManyWithoutSlot_groupInput
  }

  export type groupUncheckedCreateWithoutGroup_semesterInput = {
    id: string
    name: string
    group_inscription?: inscriptionUncheckedCreateNestedManyWithoutInscription_groupInput
    group_slot?: slotUncheckedCreateNestedManyWithoutSlot_groupInput
  }

  export type groupCreateOrConnectWithoutGroup_semesterInput = {
    where: groupWhereUniqueInput
    create: XOR<groupCreateWithoutGroup_semesterInput, groupUncheckedCreateWithoutGroup_semesterInput>
  }

  export type groupCreateManyGroup_semesterInputEnvelope = {
    data: groupCreateManyGroup_semesterInput | groupCreateManyGroup_semesterInput[]
  }

  export type course_materialCreateWithoutCourse_material_semesterInput = {
    id: string
    name: string
    course_material_session_type?: session_typeCreateNestedManyWithoutSession_type_course_materialInput
  }

  export type course_materialUncheckedCreateWithoutCourse_material_semesterInput = {
    id: string
    name: string
    course_material_session_type?: session_typeUncheckedCreateNestedManyWithoutSession_type_course_materialInput
  }

  export type course_materialCreateOrConnectWithoutCourse_material_semesterInput = {
    where: course_materialWhereUniqueInput
    create: XOR<course_materialCreateWithoutCourse_material_semesterInput, course_materialUncheckedCreateWithoutCourse_material_semesterInput>
  }

  export type course_materialCreateManyCourse_material_semesterInputEnvelope = {
    data: course_materialCreateManyCourse_material_semesterInput | course_materialCreateManyCourse_material_semesterInput[]
  }

  export type groupUpsertWithWhereUniqueWithoutGroup_semesterInput = {
    where: groupWhereUniqueInput
    update: XOR<groupUpdateWithoutGroup_semesterInput, groupUncheckedUpdateWithoutGroup_semesterInput>
    create: XOR<groupCreateWithoutGroup_semesterInput, groupUncheckedCreateWithoutGroup_semesterInput>
  }

  export type groupUpdateWithWhereUniqueWithoutGroup_semesterInput = {
    where: groupWhereUniqueInput
    data: XOR<groupUpdateWithoutGroup_semesterInput, groupUncheckedUpdateWithoutGroup_semesterInput>
  }

  export type groupUpdateManyWithWhereWithoutGroup_semesterInput = {
    where: groupScalarWhereInput
    data: XOR<groupUpdateManyMutationInput, groupUncheckedUpdateManyWithoutGroup_semesterInput>
  }

  export type groupScalarWhereInput = {
    AND?: groupScalarWhereInput | groupScalarWhereInput[]
    OR?: groupScalarWhereInput[]
    NOT?: groupScalarWhereInput | groupScalarWhereInput[]
    id?: StringFilter<"group"> | string
    name?: StringFilter<"group"> | string
    semester_id?: StringFilter<"group"> | string
  }

  export type course_materialUpsertWithWhereUniqueWithoutCourse_material_semesterInput = {
    where: course_materialWhereUniqueInput
    update: XOR<course_materialUpdateWithoutCourse_material_semesterInput, course_materialUncheckedUpdateWithoutCourse_material_semesterInput>
    create: XOR<course_materialCreateWithoutCourse_material_semesterInput, course_materialUncheckedCreateWithoutCourse_material_semesterInput>
  }

  export type course_materialUpdateWithWhereUniqueWithoutCourse_material_semesterInput = {
    where: course_materialWhereUniqueInput
    data: XOR<course_materialUpdateWithoutCourse_material_semesterInput, course_materialUncheckedUpdateWithoutCourse_material_semesterInput>
  }

  export type course_materialUpdateManyWithWhereWithoutCourse_material_semesterInput = {
    where: course_materialScalarWhereInput
    data: XOR<course_materialUpdateManyMutationInput, course_materialUncheckedUpdateManyWithoutCourse_material_semesterInput>
  }

  export type course_materialScalarWhereInput = {
    AND?: course_materialScalarWhereInput | course_materialScalarWhereInput[]
    OR?: course_materialScalarWhereInput[]
    NOT?: course_materialScalarWhereInput | course_materialScalarWhereInput[]
    id?: StringFilter<"course_material"> | string
    name?: StringFilter<"course_material"> | string
    semester_id?: StringFilter<"course_material"> | string
  }

  export type semesterCreateWithoutSemester_course_materialInput = {
    id: string
    year: Date | string
    name: string
    semester_group?: groupCreateNestedManyWithoutGroup_semesterInput
  }

  export type semesterUncheckedCreateWithoutSemester_course_materialInput = {
    id: string
    year: Date | string
    name: string
    semester_group?: groupUncheckedCreateNestedManyWithoutGroup_semesterInput
  }

  export type semesterCreateOrConnectWithoutSemester_course_materialInput = {
    where: semesterWhereUniqueInput
    create: XOR<semesterCreateWithoutSemester_course_materialInput, semesterUncheckedCreateWithoutSemester_course_materialInput>
  }

  export type session_typeCreateWithoutSession_type_course_materialInput = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
    session_type_slot?: slotCreateNestedManyWithoutSlot_seesion_typeInput
  }

  export type session_typeUncheckedCreateWithoutSession_type_course_materialInput = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
    session_type_slot?: slotUncheckedCreateNestedManyWithoutSlot_seesion_typeInput
  }

  export type session_typeCreateOrConnectWithoutSession_type_course_materialInput = {
    where: session_typeWhereUniqueInput
    create: XOR<session_typeCreateWithoutSession_type_course_materialInput, session_typeUncheckedCreateWithoutSession_type_course_materialInput>
  }

  export type session_typeCreateManySession_type_course_materialInputEnvelope = {
    data: session_typeCreateManySession_type_course_materialInput | session_typeCreateManySession_type_course_materialInput[]
  }

  export type semesterUpsertWithoutSemester_course_materialInput = {
    update: XOR<semesterUpdateWithoutSemester_course_materialInput, semesterUncheckedUpdateWithoutSemester_course_materialInput>
    create: XOR<semesterCreateWithoutSemester_course_materialInput, semesterUncheckedCreateWithoutSemester_course_materialInput>
    where?: semesterWhereInput
  }

  export type semesterUpdateToOneWithWhereWithoutSemester_course_materialInput = {
    where?: semesterWhereInput
    data: XOR<semesterUpdateWithoutSemester_course_materialInput, semesterUncheckedUpdateWithoutSemester_course_materialInput>
  }

  export type semesterUpdateWithoutSemester_course_materialInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    semester_group?: groupUpdateManyWithoutGroup_semesterNestedInput
  }

  export type semesterUncheckedUpdateWithoutSemester_course_materialInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    semester_group?: groupUncheckedUpdateManyWithoutGroup_semesterNestedInput
  }

  export type session_typeUpsertWithWhereUniqueWithoutSession_type_course_materialInput = {
    where: session_typeWhereUniqueInput
    update: XOR<session_typeUpdateWithoutSession_type_course_materialInput, session_typeUncheckedUpdateWithoutSession_type_course_materialInput>
    create: XOR<session_typeCreateWithoutSession_type_course_materialInput, session_typeUncheckedCreateWithoutSession_type_course_materialInput>
  }

  export type session_typeUpdateWithWhereUniqueWithoutSession_type_course_materialInput = {
    where: session_typeWhereUniqueInput
    data: XOR<session_typeUpdateWithoutSession_type_course_materialInput, session_typeUncheckedUpdateWithoutSession_type_course_materialInput>
  }

  export type session_typeUpdateManyWithWhereWithoutSession_type_course_materialInput = {
    where: session_typeScalarWhereInput
    data: XOR<session_typeUpdateManyMutationInput, session_typeUncheckedUpdateManyWithoutSession_type_course_materialInput>
  }

  export type session_typeScalarWhereInput = {
    AND?: session_typeScalarWhereInput | session_typeScalarWhereInput[]
    OR?: session_typeScalarWhereInput[]
    NOT?: session_typeScalarWhereInput | session_typeScalarWhereInput[]
    id?: StringFilter<"session_type"> | string
    course_type_name?: StringFilter<"session_type"> | string
    nb_repetitions?: IntFilter<"session_type"> | number
    full_promo?: BoolFilter<"session_type"> | boolean
    course_material_id?: StringFilter<"session_type"> | string
  }

  export type course_materialCreateWithoutCourse_material_session_typeInput = {
    id: string
    name: string
    course_material_semester: semesterCreateNestedOneWithoutSemester_course_materialInput
  }

  export type course_materialUncheckedCreateWithoutCourse_material_session_typeInput = {
    id: string
    name: string
    semester_id: string
  }

  export type course_materialCreateOrConnectWithoutCourse_material_session_typeInput = {
    where: course_materialWhereUniqueInput
    create: XOR<course_materialCreateWithoutCourse_material_session_typeInput, course_materialUncheckedCreateWithoutCourse_material_session_typeInput>
  }

  export type slotCreateWithoutSlot_seesion_typeInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    slot_presence?: presenceCreateNestedManyWithoutPresence_slotInput
    slot_group: groupCreateNestedOneWithoutGroup_slotInput
    slot_supervisor: supervisorCreateNestedOneWithoutSupervisor_slotInput
  }

  export type slotUncheckedCreateWithoutSlot_seesion_typeInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    group_id: string
    supervisor_id: string
    slot_presence?: presenceUncheckedCreateNestedManyWithoutPresence_slotInput
  }

  export type slotCreateOrConnectWithoutSlot_seesion_typeInput = {
    where: slotWhereUniqueInput
    create: XOR<slotCreateWithoutSlot_seesion_typeInput, slotUncheckedCreateWithoutSlot_seesion_typeInput>
  }

  export type slotCreateManySlot_seesion_typeInputEnvelope = {
    data: slotCreateManySlot_seesion_typeInput | slotCreateManySlot_seesion_typeInput[]
  }

  export type course_materialUpsertWithoutCourse_material_session_typeInput = {
    update: XOR<course_materialUpdateWithoutCourse_material_session_typeInput, course_materialUncheckedUpdateWithoutCourse_material_session_typeInput>
    create: XOR<course_materialCreateWithoutCourse_material_session_typeInput, course_materialUncheckedCreateWithoutCourse_material_session_typeInput>
    where?: course_materialWhereInput
  }

  export type course_materialUpdateToOneWithWhereWithoutCourse_material_session_typeInput = {
    where?: course_materialWhereInput
    data: XOR<course_materialUpdateWithoutCourse_material_session_typeInput, course_materialUncheckedUpdateWithoutCourse_material_session_typeInput>
  }

  export type course_materialUpdateWithoutCourse_material_session_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course_material_semester?: semesterUpdateOneRequiredWithoutSemester_course_materialNestedInput
  }

  export type course_materialUncheckedUpdateWithoutCourse_material_session_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester_id?: StringFieldUpdateOperationsInput | string
  }

  export type slotUpsertWithWhereUniqueWithoutSlot_seesion_typeInput = {
    where: slotWhereUniqueInput
    update: XOR<slotUpdateWithoutSlot_seesion_typeInput, slotUncheckedUpdateWithoutSlot_seesion_typeInput>
    create: XOR<slotCreateWithoutSlot_seesion_typeInput, slotUncheckedCreateWithoutSlot_seesion_typeInput>
  }

  export type slotUpdateWithWhereUniqueWithoutSlot_seesion_typeInput = {
    where: slotWhereUniqueInput
    data: XOR<slotUpdateWithoutSlot_seesion_typeInput, slotUncheckedUpdateWithoutSlot_seesion_typeInput>
  }

  export type slotUpdateManyWithWhereWithoutSlot_seesion_typeInput = {
    where: slotScalarWhereInput
    data: XOR<slotUpdateManyMutationInput, slotUncheckedUpdateManyWithoutSlot_seesion_typeInput>
  }

  export type studentCreateWithoutStudent_presenceInput = {
    id: string
    name: string
    first_name: string
    mail: string
    student_inscription?: inscriptionCreateNestedManyWithoutInscription_studentInput
  }

  export type studentUncheckedCreateWithoutStudent_presenceInput = {
    id: string
    name: string
    first_name: string
    mail: string
    student_inscription?: inscriptionUncheckedCreateNestedManyWithoutInscription_studentInput
  }

  export type studentCreateOrConnectWithoutStudent_presenceInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutStudent_presenceInput, studentUncheckedCreateWithoutStudent_presenceInput>
  }

  export type slotCreateWithoutSlot_presenceInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    slot_group: groupCreateNestedOneWithoutGroup_slotInput
    slot_supervisor: supervisorCreateNestedOneWithoutSupervisor_slotInput
    slot_seesion_type: session_typeCreateNestedOneWithoutSession_type_slotInput
  }

  export type slotUncheckedCreateWithoutSlot_presenceInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    group_id: string
    supervisor_id: string
    session_type_id: string
  }

  export type slotCreateOrConnectWithoutSlot_presenceInput = {
    where: slotWhereUniqueInput
    create: XOR<slotCreateWithoutSlot_presenceInput, slotUncheckedCreateWithoutSlot_presenceInput>
  }

  export type studentUpsertWithoutStudent_presenceInput = {
    update: XOR<studentUpdateWithoutStudent_presenceInput, studentUncheckedUpdateWithoutStudent_presenceInput>
    create: XOR<studentCreateWithoutStudent_presenceInput, studentUncheckedCreateWithoutStudent_presenceInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutStudent_presenceInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutStudent_presenceInput, studentUncheckedUpdateWithoutStudent_presenceInput>
  }

  export type studentUpdateWithoutStudent_presenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    student_inscription?: inscriptionUpdateManyWithoutInscription_studentNestedInput
  }

  export type studentUncheckedUpdateWithoutStudent_presenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    student_inscription?: inscriptionUncheckedUpdateManyWithoutInscription_studentNestedInput
  }

  export type slotUpsertWithoutSlot_presenceInput = {
    update: XOR<slotUpdateWithoutSlot_presenceInput, slotUncheckedUpdateWithoutSlot_presenceInput>
    create: XOR<slotCreateWithoutSlot_presenceInput, slotUncheckedCreateWithoutSlot_presenceInput>
    where?: slotWhereInput
  }

  export type slotUpdateToOneWithWhereWithoutSlot_presenceInput = {
    where?: slotWhereInput
    data: XOR<slotUpdateWithoutSlot_presenceInput, slotUncheckedUpdateWithoutSlot_presenceInput>
  }

  export type slotUpdateWithoutSlot_presenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    slot_group?: groupUpdateOneRequiredWithoutGroup_slotNestedInput
    slot_supervisor?: supervisorUpdateOneRequiredWithoutSupervisor_slotNestedInput
    slot_seesion_type?: session_typeUpdateOneRequiredWithoutSession_type_slotNestedInput
  }

  export type slotUncheckedUpdateWithoutSlot_presenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    session_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type presenceCreateWithoutPresence_slotInput = {
    presence_student: studentCreateNestedOneWithoutStudent_presenceInput
  }

  export type presenceUncheckedCreateWithoutPresence_slotInput = {
    student_id: string
  }

  export type presenceCreateOrConnectWithoutPresence_slotInput = {
    where: presenceWhereUniqueInput
    create: XOR<presenceCreateWithoutPresence_slotInput, presenceUncheckedCreateWithoutPresence_slotInput>
  }

  export type presenceCreateManyPresence_slotInputEnvelope = {
    data: presenceCreateManyPresence_slotInput | presenceCreateManyPresence_slotInput[]
  }

  export type groupCreateWithoutGroup_slotInput = {
    id: string
    name: string
    group_semester: semesterCreateNestedOneWithoutSemester_groupInput
    group_inscription?: inscriptionCreateNestedManyWithoutInscription_groupInput
  }

  export type groupUncheckedCreateWithoutGroup_slotInput = {
    id: string
    name: string
    semester_id: string
    group_inscription?: inscriptionUncheckedCreateNestedManyWithoutInscription_groupInput
  }

  export type groupCreateOrConnectWithoutGroup_slotInput = {
    where: groupWhereUniqueInput
    create: XOR<groupCreateWithoutGroup_slotInput, groupUncheckedCreateWithoutGroup_slotInput>
  }

  export type supervisorCreateWithoutSupervisor_slotInput = {
    id: string
    name: string
    mail: string
  }

  export type supervisorUncheckedCreateWithoutSupervisor_slotInput = {
    id: string
    name: string
    mail: string
  }

  export type supervisorCreateOrConnectWithoutSupervisor_slotInput = {
    where: supervisorWhereUniqueInput
    create: XOR<supervisorCreateWithoutSupervisor_slotInput, supervisorUncheckedCreateWithoutSupervisor_slotInput>
  }

  export type session_typeCreateWithoutSession_type_slotInput = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
    session_type_course_material: course_materialCreateNestedOneWithoutCourse_material_session_typeInput
  }

  export type session_typeUncheckedCreateWithoutSession_type_slotInput = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
    course_material_id: string
  }

  export type session_typeCreateOrConnectWithoutSession_type_slotInput = {
    where: session_typeWhereUniqueInput
    create: XOR<session_typeCreateWithoutSession_type_slotInput, session_typeUncheckedCreateWithoutSession_type_slotInput>
  }

  export type presenceUpsertWithWhereUniqueWithoutPresence_slotInput = {
    where: presenceWhereUniqueInput
    update: XOR<presenceUpdateWithoutPresence_slotInput, presenceUncheckedUpdateWithoutPresence_slotInput>
    create: XOR<presenceCreateWithoutPresence_slotInput, presenceUncheckedCreateWithoutPresence_slotInput>
  }

  export type presenceUpdateWithWhereUniqueWithoutPresence_slotInput = {
    where: presenceWhereUniqueInput
    data: XOR<presenceUpdateWithoutPresence_slotInput, presenceUncheckedUpdateWithoutPresence_slotInput>
  }

  export type presenceUpdateManyWithWhereWithoutPresence_slotInput = {
    where: presenceScalarWhereInput
    data: XOR<presenceUpdateManyMutationInput, presenceUncheckedUpdateManyWithoutPresence_slotInput>
  }

  export type groupUpsertWithoutGroup_slotInput = {
    update: XOR<groupUpdateWithoutGroup_slotInput, groupUncheckedUpdateWithoutGroup_slotInput>
    create: XOR<groupCreateWithoutGroup_slotInput, groupUncheckedCreateWithoutGroup_slotInput>
    where?: groupWhereInput
  }

  export type groupUpdateToOneWithWhereWithoutGroup_slotInput = {
    where?: groupWhereInput
    data: XOR<groupUpdateWithoutGroup_slotInput, groupUncheckedUpdateWithoutGroup_slotInput>
  }

  export type groupUpdateWithoutGroup_slotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group_semester?: semesterUpdateOneRequiredWithoutSemester_groupNestedInput
    group_inscription?: inscriptionUpdateManyWithoutInscription_groupNestedInput
  }

  export type groupUncheckedUpdateWithoutGroup_slotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    semester_id?: StringFieldUpdateOperationsInput | string
    group_inscription?: inscriptionUncheckedUpdateManyWithoutInscription_groupNestedInput
  }

  export type supervisorUpsertWithoutSupervisor_slotInput = {
    update: XOR<supervisorUpdateWithoutSupervisor_slotInput, supervisorUncheckedUpdateWithoutSupervisor_slotInput>
    create: XOR<supervisorCreateWithoutSupervisor_slotInput, supervisorUncheckedCreateWithoutSupervisor_slotInput>
    where?: supervisorWhereInput
  }

  export type supervisorUpdateToOneWithWhereWithoutSupervisor_slotInput = {
    where?: supervisorWhereInput
    data: XOR<supervisorUpdateWithoutSupervisor_slotInput, supervisorUncheckedUpdateWithoutSupervisor_slotInput>
  }

  export type supervisorUpdateWithoutSupervisor_slotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
  }

  export type supervisorUncheckedUpdateWithoutSupervisor_slotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
  }

  export type session_typeUpsertWithoutSession_type_slotInput = {
    update: XOR<session_typeUpdateWithoutSession_type_slotInput, session_typeUncheckedUpdateWithoutSession_type_slotInput>
    create: XOR<session_typeCreateWithoutSession_type_slotInput, session_typeUncheckedCreateWithoutSession_type_slotInput>
    where?: session_typeWhereInput
  }

  export type session_typeUpdateToOneWithWhereWithoutSession_type_slotInput = {
    where?: session_typeWhereInput
    data: XOR<session_typeUpdateWithoutSession_type_slotInput, session_typeUncheckedUpdateWithoutSession_type_slotInput>
  }

  export type session_typeUpdateWithoutSession_type_slotInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
    session_type_course_material?: course_materialUpdateOneRequiredWithoutCourse_material_session_typeNestedInput
  }

  export type session_typeUncheckedUpdateWithoutSession_type_slotInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
    course_material_id?: StringFieldUpdateOperationsInput | string
  }

  export type slotCreateManySlot_supervisorInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    group_id: string
    session_type_id: string
  }

  export type slotUpdateWithoutSlot_supervisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    slot_presence?: presenceUpdateManyWithoutPresence_slotNestedInput
    slot_group?: groupUpdateOneRequiredWithoutGroup_slotNestedInput
    slot_seesion_type?: session_typeUpdateOneRequiredWithoutSession_type_slotNestedInput
  }

  export type slotUncheckedUpdateWithoutSlot_supervisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    session_type_id?: StringFieldUpdateOperationsInput | string
    slot_presence?: presenceUncheckedUpdateManyWithoutPresence_slotNestedInput
  }

  export type slotUncheckedUpdateManyWithoutSlot_supervisorInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    session_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type inscriptionCreateManyInscription_studentInput = {
    group_id: string
  }

  export type presenceCreateManyPresence_studentInput = {
    slot_id: string
  }

  export type inscriptionUpdateWithoutInscription_studentInput = {
    inscription_group?: groupUpdateOneRequiredWithoutGroup_inscriptionNestedInput
  }

  export type inscriptionUncheckedUpdateWithoutInscription_studentInput = {
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type inscriptionUncheckedUpdateManyWithoutInscription_studentInput = {
    group_id?: StringFieldUpdateOperationsInput | string
  }

  export type presenceUpdateWithoutPresence_studentInput = {
    presence_slot?: slotUpdateOneRequiredWithoutSlot_presenceNestedInput
  }

  export type presenceUncheckedUpdateWithoutPresence_studentInput = {
    slot_id?: StringFieldUpdateOperationsInput | string
  }

  export type presenceUncheckedUpdateManyWithoutPresence_studentInput = {
    slot_id?: StringFieldUpdateOperationsInput | string
  }

  export type inscriptionCreateManyInscription_groupInput = {
    student_id: string
  }

  export type slotCreateManySlot_groupInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    supervisor_id: string
    session_type_id: string
  }

  export type inscriptionUpdateWithoutInscription_groupInput = {
    inscription_student?: studentUpdateOneRequiredWithoutStudent_inscriptionNestedInput
  }

  export type inscriptionUncheckedUpdateWithoutInscription_groupInput = {
    student_id?: StringFieldUpdateOperationsInput | string
  }

  export type inscriptionUncheckedUpdateManyWithoutInscription_groupInput = {
    student_id?: StringFieldUpdateOperationsInput | string
  }

  export type slotUpdateWithoutSlot_groupInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    slot_presence?: presenceUpdateManyWithoutPresence_slotNestedInput
    slot_supervisor?: supervisorUpdateOneRequiredWithoutSupervisor_slotNestedInput
    slot_seesion_type?: session_typeUpdateOneRequiredWithoutSession_type_slotNestedInput
  }

  export type slotUncheckedUpdateWithoutSlot_groupInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    supervisor_id?: StringFieldUpdateOperationsInput | string
    session_type_id?: StringFieldUpdateOperationsInput | string
    slot_presence?: presenceUncheckedUpdateManyWithoutPresence_slotNestedInput
  }

  export type slotUncheckedUpdateManyWithoutSlot_groupInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    supervisor_id?: StringFieldUpdateOperationsInput | string
    session_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type groupCreateManyGroup_semesterInput = {
    id: string
    name: string
  }

  export type course_materialCreateManyCourse_material_semesterInput = {
    id: string
    name: string
  }

  export type groupUpdateWithoutGroup_semesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group_inscription?: inscriptionUpdateManyWithoutInscription_groupNestedInput
    group_slot?: slotUpdateManyWithoutSlot_groupNestedInput
  }

  export type groupUncheckedUpdateWithoutGroup_semesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group_inscription?: inscriptionUncheckedUpdateManyWithoutInscription_groupNestedInput
    group_slot?: slotUncheckedUpdateManyWithoutSlot_groupNestedInput
  }

  export type groupUncheckedUpdateManyWithoutGroup_semesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type course_materialUpdateWithoutCourse_material_semesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course_material_session_type?: session_typeUpdateManyWithoutSession_type_course_materialNestedInput
  }

  export type course_materialUncheckedUpdateWithoutCourse_material_semesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    course_material_session_type?: session_typeUncheckedUpdateManyWithoutSession_type_course_materialNestedInput
  }

  export type course_materialUncheckedUpdateManyWithoutCourse_material_semesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type session_typeCreateManySession_type_course_materialInput = {
    id: string
    course_type_name: string
    nb_repetitions: number
    full_promo: boolean
  }

  export type session_typeUpdateWithoutSession_type_course_materialInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
    session_type_slot?: slotUpdateManyWithoutSlot_seesion_typeNestedInput
  }

  export type session_typeUncheckedUpdateWithoutSession_type_course_materialInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
    session_type_slot?: slotUncheckedUpdateManyWithoutSlot_seesion_typeNestedInput
  }

  export type session_typeUncheckedUpdateManyWithoutSession_type_course_materialInput = {
    id?: StringFieldUpdateOperationsInput | string
    course_type_name?: StringFieldUpdateOperationsInput | string
    nb_repetitions?: IntFieldUpdateOperationsInput | number
    full_promo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type slotCreateManySlot_seesion_typeInput = {
    id: string
    starting_time: Date | string
    date: Date | string
    num_session: number
    group_id: string
    supervisor_id: string
  }

  export type slotUpdateWithoutSlot_seesion_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    slot_presence?: presenceUpdateManyWithoutPresence_slotNestedInput
    slot_group?: groupUpdateOneRequiredWithoutGroup_slotNestedInput
    slot_supervisor?: supervisorUpdateOneRequiredWithoutSupervisor_slotNestedInput
  }

  export type slotUncheckedUpdateWithoutSlot_seesion_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
    slot_presence?: presenceUncheckedUpdateManyWithoutPresence_slotNestedInput
  }

  export type slotUncheckedUpdateManyWithoutSlot_seesion_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    starting_time?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    num_session?: IntFieldUpdateOperationsInput | number
    group_id?: StringFieldUpdateOperationsInput | string
    supervisor_id?: StringFieldUpdateOperationsInput | string
  }

  export type presenceCreateManyPresence_slotInput = {
    student_id: string
  }

  export type presenceUpdateWithoutPresence_slotInput = {
    presence_student?: studentUpdateOneRequiredWithoutStudent_presenceNestedInput
  }

  export type presenceUncheckedUpdateWithoutPresence_slotInput = {
    student_id?: StringFieldUpdateOperationsInput | string
  }

  export type presenceUncheckedUpdateManyWithoutPresence_slotInput = {
    student_id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}